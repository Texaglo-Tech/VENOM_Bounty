{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SubscriptionController = void 0;\nconst await_semaphore_1 = require(\"@broxus/await-semaphore\");\nconst utils_1 = require(\"../utils\");\nconst subscription_1 = require(\"./subscription\");\nconst DEFAULT_POLLING_INTERVAL = 10000; // 10s\nclass SubscriptionController {\n  constructor(connectionController, notify) {\n    this._subscriptions = new Map();\n    this._subscriptionsMutex = new await_semaphore_1.Mutex();\n    this._sendMessageRequests = new Map();\n    this._subscriptionStates = new Map();\n    this._connectionController = connectionController;\n    this._notify = notify;\n  }\n  async sendMessageLocally(address, signedMessage, params) {\n    const subscriptionId = (0, utils_1.getUniqueId)();\n    try {\n      await this.subscribeToContract(address, {\n        state: true\n      }, subscriptionId);\n      const subscription = this._subscriptions.get(address);\n      if (subscription == null) {\n        throw new Error('Failed to subscribe to contract');\n      }\n      return await subscription.use(contract => contract.sendMessageLocally(signedMessage, params));\n    } finally {\n      this.unsubscribeFromContract(address, subscriptionId).catch(console.error);\n    }\n  }\n  sendMessage(address, signedMessage) {\n    let messageRequests = this._sendMessageRequests.get(address);\n    if (messageRequests == null) {\n      messageRequests = new Map();\n      this._sendMessageRequests.set(address, messageRequests);\n    }\n    const subscriptionId = (0, utils_1.getUniqueId)();\n    return new Promise((resolve, reject) => {\n      const id = signedMessage.hash;\n      messageRequests.set(id, {\n        resolve,\n        reject\n      });\n      this.subscribeToContract(address, {\n        state: true\n      }, subscriptionId).then(async () => {\n        const subscription = this._subscriptions.get(address);\n        if (subscription == null) {\n          throw new Error('Failed to subscribe to contract');\n        }\n        await subscription.prepareReliablePolling();\n        await subscription.use(async contract => {\n          await contract.sendMessage(signedMessage);\n          subscription.skipRefreshTimer(contract.pollingMethod);\n        });\n      }).catch(e => this._rejectMessageRequest(address, id, e)).finally(() => {\n        this.unsubscribeFromContract(address, subscriptionId).catch(console.error);\n      });\n    });\n  }\n  async subscribeToContract(address, params, internalId) {\n    return this._subscriptionsMutex.use(async () => {\n      const mergeInputParams = currentParams => {\n        const newParams = {\n          ...currentParams\n        };\n        Object.keys(newParams).map(param => {\n          if (param !== 'state' && param !== 'transactions') {\n            throw new Error(`Unknown subscription topic: ${param}`);\n          }\n          const value = params[param];\n          if (typeof value === 'boolean') {\n            newParams[param] = value;\n          } else if (value == null) {\n            return;\n          } else {\n            throw new Error(`Unknown subscription topic value ${param}: ${value}`);\n          }\n        });\n        return newParams;\n      };\n      const subscriptionState = this._subscriptionStates.get(address) || makeDefaultSubscriptionState();\n      let changedParams;\n      if (internalId == null) {\n        // Client subscription without id\n        // Changed params are `SubscriptionState.client`\n        changedParams = mergeInputParams(subscriptionState.client);\n      } else {\n        // Internal subscription with id\n        // Changed params are `SubscriptionState.internal[internalId]`\n        const exisingParams = subscriptionState.internal.get(internalId);\n        if (exisingParams != null) {\n          // Updating existing internal params\n          changedParams = mergeInputParams(exisingParams);\n          // Remove entry if it is empty\n          if (isEmptySubscription(changedParams)) {\n            subscriptionState.internal.delete(internalId);\n          }\n        } else {\n          // Merge input params with empty struct\n          changedParams = mergeInputParams({\n            state: false,\n            transactions: false\n          });\n        }\n      }\n      // Merge changed params with the rest of internal params\n      const computedParams = {\n        ...changedParams\n      };\n      for (const params of subscriptionState.internal.values()) {\n        computedParams.state || (computedParams.state = params.state);\n        computedParams.transactions || (computedParams.transactions = params.transactions);\n      }\n      // Remove subscription if all params are empty\n      if (isEmptySubscription(computedParams)) {\n        this._subscriptionStates.delete(address);\n        await this._tryUnsubscribe(address);\n        return {\n          ...computedParams\n        };\n      }\n      // Create subscription if it doesn't exist\n      let existingSubscription = this._subscriptions.get(address);\n      const isNewSubscription = existingSubscription == null;\n      if (existingSubscription == null) {\n        existingSubscription = await this._createSubscription(address);\n      }\n      // Update subscription state\n      if (internalId == null) {\n        // Update client params\n        subscriptionState.client = changedParams;\n      } else {\n        // Set new internal params\n        subscriptionState.internal.set(internalId, changedParams);\n      }\n      this._subscriptionStates.set(address, subscriptionState);\n      // Start subscription\n      if (isNewSubscription) {\n        await existingSubscription.start();\n      }\n      // Returns only changed params\n      return {\n        ...changedParams\n      };\n    });\n  }\n  async unsubscribeFromContract(address, internalId) {\n    await this.subscribeToContract(address, {\n      state: false,\n      transactions: false\n    }, internalId);\n  }\n  async unsubscribeFromAllContracts(internalId) {\n    for (const address of this._subscriptions.keys()) {\n      await this.unsubscribeFromContract(address, internalId);\n    }\n  }\n  get subscriptionStates() {\n    const result = {};\n    for (const [key, value] of this._subscriptionStates.entries()) {\n      result[key] = {\n        ...value.client\n      };\n    }\n    return result;\n  }\n  async _createSubscription(address) {\n    class ContractHandler {\n      constructor(address, controller) {\n        this._enabled = false;\n        this._address = address;\n        this._controller = controller;\n      }\n      enableNotifications() {\n        this._enabled = true;\n      }\n      onMessageExpired(pendingTransaction) {\n        this._controller._resolveMessageRequest(this._address, pendingTransaction.messageHash, undefined).catch(console.error);\n      }\n      onMessageSent(pendingTransaction, transaction) {\n        this._controller._resolveMessageRequest(this._address, pendingTransaction.messageHash, transaction).catch(console.error);\n      }\n      onStateChanged(newState) {\n        if (this._enabled) {\n          this._controller._notifyStateChanged(this._address, newState);\n        }\n      }\n      onTransactionsFound(transactions, info) {\n        if (this._enabled) {\n          this._controller._notifyTransactionsFound(this._address, transactions, info);\n        }\n      }\n    }\n    const handler = new ContractHandler(address, this);\n    const subscription = await subscription_1.ContractSubscription.subscribe(this._connectionController, address, handler);\n    subscription.setPollingInterval(DEFAULT_POLLING_INTERVAL);\n    handler.enableNotifications();\n    this._subscriptions.set(address, subscription);\n    return subscription;\n  }\n  async _tryUnsubscribe(address) {\n    const subscriptionState = this._subscriptionStates.get(address);\n    const sendMessageRequests = this._sendMessageRequests.get(address);\n    if (subscriptionState == null && ((sendMessageRequests === null || sendMessageRequests === void 0 ? void 0 : sendMessageRequests.size) || 0) == 0) {\n      const subscription = this._subscriptions.get(address);\n      this._subscriptions.delete(address);\n      await (subscription === null || subscription === void 0 ? void 0 : subscription.stop());\n    }\n  }\n  async _rejectMessageRequest(address, id, error) {\n    this._deleteMessageRequestAndGetCallback(address, id).reject(error);\n    await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));\n  }\n  async _resolveMessageRequest(address, id, transaction) {\n    this._deleteMessageRequestAndGetCallback(address, id).resolve(transaction);\n    await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));\n  }\n  _notifyStateChanged(address, state) {\n    const subscriptionState = this._subscriptionStates.get(address);\n    if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.state) {\n      this._notify('contractStateChanged', {\n        address,\n        state\n      });\n    }\n  }\n  _notifyTransactionsFound(address, transactions, info) {\n    const subscriptionState = this._subscriptionStates.get(address);\n    if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.transactions) {\n      this._notify('transactionsFound', {\n        address,\n        transactions,\n        info\n      });\n    }\n  }\n  _deleteMessageRequestAndGetCallback(address, id) {\n    var _a;\n    const callbacks = (_a = this._sendMessageRequests.get(address)) === null || _a === void 0 ? void 0 : _a.get(id);\n    if (!callbacks) {\n      throw new Error(`SendMessage request with id '${id}' not found`);\n    }\n    this._deleteMessageRequest(address, id);\n    return callbacks;\n  }\n  _deleteMessageRequest(address, id) {\n    const accountMessageRequests = this._sendMessageRequests.get(address);\n    if (!accountMessageRequests) {\n      return;\n    }\n    accountMessageRequests.delete(id);\n    if (accountMessageRequests.size == 0) {\n      this._sendMessageRequests.delete(address);\n    }\n  }\n}\nexports.SubscriptionController = SubscriptionController;\nconst makeDefaultSubscriptionState = () => ({\n  internal: new Map(),\n  client: {\n    state: false,\n    transactions: false\n  }\n});\nconst isEmptySubscription = params => !params.state && !params.transactions;","map":{"version":3,"names":["Object","defineProperty","exports","value","SubscriptionController","await_semaphore_1","require","utils_1","subscription_1","DEFAULT_POLLING_INTERVAL","constructor","connectionController","notify","_subscriptions","Map","_subscriptionsMutex","Mutex","_sendMessageRequests","_subscriptionStates","_connectionController","_notify","sendMessageLocally","address","signedMessage","params","subscriptionId","getUniqueId","subscribeToContract","state","subscription","get","Error","use","contract","unsubscribeFromContract","catch","console","error","sendMessage","messageRequests","set","Promise","resolve","reject","id","hash","then","prepareReliablePolling","skipRefreshTimer","pollingMethod","e","_rejectMessageRequest","finally","internalId","mergeInputParams","currentParams","newParams","keys","map","param","subscriptionState","makeDefaultSubscriptionState","changedParams","client","exisingParams","internal","isEmptySubscription","delete","transactions","computedParams","values","_tryUnsubscribe","existingSubscription","isNewSubscription","_createSubscription","start","unsubscribeFromAllContracts","subscriptionStates","result","key","entries","ContractHandler","controller","_enabled","_address","_controller","enableNotifications","onMessageExpired","pendingTransaction","_resolveMessageRequest","messageHash","undefined","onMessageSent","transaction","onStateChanged","newState","_notifyStateChanged","onTransactionsFound","info","_notifyTransactionsFound","handler","ContractSubscription","subscribe","setPollingInterval","sendMessageRequests","size","stop","_deleteMessageRequestAndGetCallback","_a","callbacks","_deleteMessageRequest","accountMessageRequests"],"sources":["/home/king/Desktop/venom-connect-main/examples/react/node_modules/everscale-standalone-client/client/SubscriptionController/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SubscriptionController = void 0;\nconst await_semaphore_1 = require(\"@broxus/await-semaphore\");\nconst utils_1 = require(\"../utils\");\nconst subscription_1 = require(\"./subscription\");\nconst DEFAULT_POLLING_INTERVAL = 10000; // 10s\nclass SubscriptionController {\n    constructor(connectionController, notify) {\n        this._subscriptions = new Map();\n        this._subscriptionsMutex = new await_semaphore_1.Mutex();\n        this._sendMessageRequests = new Map();\n        this._subscriptionStates = new Map();\n        this._connectionController = connectionController;\n        this._notify = notify;\n    }\n    async sendMessageLocally(address, signedMessage, params) {\n        const subscriptionId = (0, utils_1.getUniqueId)();\n        try {\n            await this.subscribeToContract(address, { state: true }, subscriptionId);\n            const subscription = this._subscriptions.get(address);\n            if (subscription == null) {\n                throw new Error('Failed to subscribe to contract');\n            }\n            return await subscription.use(contract => contract.sendMessageLocally(signedMessage, params));\n        }\n        finally {\n            this.unsubscribeFromContract(address, subscriptionId).catch(console.error);\n        }\n    }\n    sendMessage(address, signedMessage) {\n        let messageRequests = this._sendMessageRequests.get(address);\n        if (messageRequests == null) {\n            messageRequests = new Map();\n            this._sendMessageRequests.set(address, messageRequests);\n        }\n        const subscriptionId = (0, utils_1.getUniqueId)();\n        return new Promise((resolve, reject) => {\n            const id = signedMessage.hash;\n            messageRequests.set(id, { resolve, reject });\n            this.subscribeToContract(address, { state: true }, subscriptionId)\n                .then(async () => {\n                const subscription = this._subscriptions.get(address);\n                if (subscription == null) {\n                    throw new Error('Failed to subscribe to contract');\n                }\n                await subscription.prepareReliablePolling();\n                await subscription.use(async (contract) => {\n                    await contract.sendMessage(signedMessage);\n                    subscription.skipRefreshTimer(contract.pollingMethod);\n                });\n            })\n                .catch((e) => this._rejectMessageRequest(address, id, e))\n                .finally(() => {\n                this.unsubscribeFromContract(address, subscriptionId).catch(console.error);\n            });\n        });\n    }\n    async subscribeToContract(address, params, internalId) {\n        return this._subscriptionsMutex.use(async () => {\n            const mergeInputParams = (currentParams) => {\n                const newParams = { ...currentParams };\n                Object.keys(newParams).map(param => {\n                    if (param !== 'state' && param !== 'transactions') {\n                        throw new Error(`Unknown subscription topic: ${param}`);\n                    }\n                    const value = params[param];\n                    if (typeof value === 'boolean') {\n                        newParams[param] = value;\n                    }\n                    else if (value == null) {\n                        return;\n                    }\n                    else {\n                        throw new Error(`Unknown subscription topic value ${param}: ${value}`);\n                    }\n                });\n                return newParams;\n            };\n            const subscriptionState = this._subscriptionStates.get(address) || makeDefaultSubscriptionState();\n            let changedParams;\n            if (internalId == null) {\n                // Client subscription without id\n                // Changed params are `SubscriptionState.client`\n                changedParams = mergeInputParams(subscriptionState.client);\n            }\n            else {\n                // Internal subscription with id\n                // Changed params are `SubscriptionState.internal[internalId]`\n                const exisingParams = subscriptionState.internal.get(internalId);\n                if (exisingParams != null) {\n                    // Updating existing internal params\n                    changedParams = mergeInputParams(exisingParams);\n                    // Remove entry if it is empty\n                    if (isEmptySubscription(changedParams)) {\n                        subscriptionState.internal.delete(internalId);\n                    }\n                }\n                else {\n                    // Merge input params with empty struct\n                    changedParams = mergeInputParams({ state: false, transactions: false });\n                }\n            }\n            // Merge changed params with the rest of internal params\n            const computedParams = { ...changedParams };\n            for (const params of subscriptionState.internal.values()) {\n                computedParams.state || (computedParams.state = params.state);\n                computedParams.transactions || (computedParams.transactions = params.transactions);\n            }\n            // Remove subscription if all params are empty\n            if (isEmptySubscription(computedParams)) {\n                this._subscriptionStates.delete(address);\n                await this._tryUnsubscribe(address);\n                return { ...computedParams };\n            }\n            // Create subscription if it doesn't exist\n            let existingSubscription = this._subscriptions.get(address);\n            const isNewSubscription = existingSubscription == null;\n            if (existingSubscription == null) {\n                existingSubscription = await this._createSubscription(address);\n            }\n            // Update subscription state\n            if (internalId == null) {\n                // Update client params\n                subscriptionState.client = changedParams;\n            }\n            else {\n                // Set new internal params\n                subscriptionState.internal.set(internalId, changedParams);\n            }\n            this._subscriptionStates.set(address, subscriptionState);\n            // Start subscription\n            if (isNewSubscription) {\n                await existingSubscription.start();\n            }\n            // Returns only changed params\n            return { ...changedParams };\n        });\n    }\n    async unsubscribeFromContract(address, internalId) {\n        await this.subscribeToContract(address, {\n            state: false,\n            transactions: false,\n        }, internalId);\n    }\n    async unsubscribeFromAllContracts(internalId) {\n        for (const address of this._subscriptions.keys()) {\n            await this.unsubscribeFromContract(address, internalId);\n        }\n    }\n    get subscriptionStates() {\n        const result = {};\n        for (const [key, value] of this._subscriptionStates.entries()) {\n            result[key] = { ...value.client };\n        }\n        return result;\n    }\n    async _createSubscription(address) {\n        class ContractHandler {\n            constructor(address, controller) {\n                this._enabled = false;\n                this._address = address;\n                this._controller = controller;\n            }\n            enableNotifications() {\n                this._enabled = true;\n            }\n            onMessageExpired(pendingTransaction) {\n                this._controller\n                    ._resolveMessageRequest(this._address, pendingTransaction.messageHash, undefined)\n                    .catch(console.error);\n            }\n            onMessageSent(pendingTransaction, transaction) {\n                this._controller\n                    ._resolveMessageRequest(this._address, pendingTransaction.messageHash, transaction)\n                    .catch(console.error);\n            }\n            onStateChanged(newState) {\n                if (this._enabled) {\n                    this._controller._notifyStateChanged(this._address, newState);\n                }\n            }\n            onTransactionsFound(transactions, info) {\n                if (this._enabled) {\n                    this._controller._notifyTransactionsFound(this._address, transactions, info);\n                }\n            }\n        }\n        const handler = new ContractHandler(address, this);\n        const subscription = await subscription_1.ContractSubscription.subscribe(this._connectionController, address, handler);\n        subscription.setPollingInterval(DEFAULT_POLLING_INTERVAL);\n        handler.enableNotifications();\n        this._subscriptions.set(address, subscription);\n        return subscription;\n    }\n    async _tryUnsubscribe(address) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        const sendMessageRequests = this._sendMessageRequests.get(address);\n        if (subscriptionState == null && ((sendMessageRequests === null || sendMessageRequests === void 0 ? void 0 : sendMessageRequests.size) || 0) == 0) {\n            const subscription = this._subscriptions.get(address);\n            this._subscriptions.delete(address);\n            await (subscription === null || subscription === void 0 ? void 0 : subscription.stop());\n        }\n    }\n    async _rejectMessageRequest(address, id, error) {\n        this._deleteMessageRequestAndGetCallback(address, id).reject(error);\n        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));\n    }\n    async _resolveMessageRequest(address, id, transaction) {\n        this._deleteMessageRequestAndGetCallback(address, id).resolve(transaction);\n        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));\n    }\n    _notifyStateChanged(address, state) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.state) {\n            this._notify('contractStateChanged', {\n                address,\n                state,\n            });\n        }\n    }\n    _notifyTransactionsFound(address, transactions, info) {\n        const subscriptionState = this._subscriptionStates.get(address);\n        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.transactions) {\n            this._notify('transactionsFound', {\n                address,\n                transactions,\n                info,\n            });\n        }\n    }\n    _deleteMessageRequestAndGetCallback(address, id) {\n        var _a;\n        const callbacks = (_a = this._sendMessageRequests.get(address)) === null || _a === void 0 ? void 0 : _a.get(id);\n        if (!callbacks) {\n            throw new Error(`SendMessage request with id '${id}' not found`);\n        }\n        this._deleteMessageRequest(address, id);\n        return callbacks;\n    }\n    _deleteMessageRequest(address, id) {\n        const accountMessageRequests = this._sendMessageRequests.get(address);\n        if (!accountMessageRequests) {\n            return;\n        }\n        accountMessageRequests.delete(id);\n        if (accountMessageRequests.size == 0) {\n            this._sendMessageRequests.delete(address);\n        }\n    }\n}\nexports.SubscriptionController = SubscriptionController;\nconst makeDefaultSubscriptionState = () => ({\n    internal: new Map(),\n    client: {\n        state: false,\n        transactions: false,\n    },\n});\nconst isEmptySubscription = (params) => !params.state && !params.transactions;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}