{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TvmException = exports.Contract = void 0;\nconst utils_1 = require(\"./utils\");\nconst models_1 = require(\"./models\");\n/**\n * @category Contract\n */\nclass Contract {\n  constructor(provider, abi, address) {\n    var _this = this;\n    if (!Array.isArray(abi.functions)) {\n      throw new Error('Invalid abi. Functions array required');\n    }\n    if (!Array.isArray(abi.events)) {\n      throw new Error('Invalid abi. Events array required');\n    }\n    this._provider = provider;\n    this._abi = JSON.stringify(abi);\n    this.methodsAbi = abi.functions.reduce((functions, item) => {\n      if (item.inputs == null) {\n        item.inputs = [];\n      }\n      if (item.outputs == null) {\n        item.outputs = [];\n      }\n      functions[item.name] = item;\n      return functions;\n    }, {});\n    this.eventsAbi = abi.events.reduce((events, item) => {\n      if (item.inputs == null) {\n        item.inputs = [];\n      }\n      events[item.name] = item;\n      return events;\n    }, {});\n    this.fieldsAbi = abi.fields;\n    this._address = address;\n    this._methods = new Proxy({}, {\n      get: (_object, method) => {\n        const rawAbi = this.methodsAbi[method];\n        return function () {\n          let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return new ContractMethodImpl(_this._provider, rawAbi, _this._abi, _this._address, method, params);\n        };\n      }\n    });\n    this._fields = new Proxy({}, {\n      get: (_object, field) => {\n        return async function () {\n          let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          await _this._provider.ensureInitialized();\n          const {\n            fields,\n            state\n          } = await _this._provider.rawApi.getContractFields({\n            address: _this._address.toString(),\n            abi: _this._abi,\n            cachedState: params === null || params === void 0 ? void 0 : params.cachedState,\n            allowPartial: (params === null || params === void 0 ? void 0 : params.allowPartial) == null ? false : params.allowPartial\n          });\n          if (fields == null) {\n            if (state == null) {\n              throw new Error('Account does not exist');\n            } else if (!state.isDeployed) {\n              throw new Error('Account is not deployed');\n            } else {\n              throw new Error('Invalid account data');\n            }\n          }\n          const parsedFields = (0, models_1.parseTokensObject)(_this.fieldsAbi, fields);\n          if (parsedFields == null || !Object.prototype.hasOwnProperty.call(parsedFields, field)) {\n            throw new Error('Unknown field');\n          }\n          return parsedFields[field];\n        };\n      }\n    });\n  }\n  get methods() {\n    return this._methods;\n  }\n  get fields() {\n    return this._fields;\n  }\n  get address() {\n    return this._address;\n  }\n  get abi() {\n    return this._abi;\n  }\n  /**\n   * Requests contract data\n   *\n   * ---\n   * Required permissions: `basic`\n   */\n  async getFullState() {\n    await this._provider.ensureInitialized();\n    return await this._provider.rawApi.getFullContractState({\n      address: this.address.toString()\n    });\n  }\n  /**\n   * Unpacks all fields from the contract state using the specified ABI\n   *\n   * ---\n   * Required permissions: `basic`\n   */\n  async getFields() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await this._provider.ensureInitialized();\n    const {\n      fields,\n      state\n    } = await this._provider.rawApi.getContractFields({\n      address: this.address.toString(),\n      abi: this._abi,\n      cachedState: args.cachedState,\n      allowPartial: args.allowPartial == null ? false : args.allowPartial\n    });\n    return {\n      fields: fields != null ? (0, models_1.parseTokensObject)(this.fieldsAbi, fields) : undefined,\n      state\n    };\n  }\n  /**\n   * Creates new contract transactions stream\n   *\n   * @param subscriber\n   */\n  transactions(subscriber) {\n    return subscriber.transactions(this._address).flatMap(_ref => {\n      let {\n        transactions\n      } = _ref;\n      return transactions;\n    });\n  }\n  /**\n   * Creates new contract events stream\n   *\n   * @param subscriber\n   */\n  events(subscriber) {\n    return subscriber.transactions(this._address).flatMap(_ref2 => {\n      let {\n        transactions\n      } = _ref2;\n      return transactions;\n    }).flatMap(tx => this.decodeTransactionEvents({\n      transaction: tx\n    }).then(events => {\n      events.forEach(event => event.transaction = tx);\n      return events;\n    }));\n  }\n  async waitForEvent() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      range,\n      filter\n    } = args;\n    const filterFn = typeof filter === 'string' ? _ref3 => {\n      let {\n        event\n      } = _ref3;\n      return event === filter;\n    } : filter;\n    let subscriber = args.subscriber;\n    const hasTempSubscriber = subscriber == null;\n    if (subscriber == null) {\n      subscriber = new this._provider.Subscriber();\n    }\n    const event = await ((range === null || range === void 0 ? void 0 : range.fromLt) != null || (range === null || range === void 0 ? void 0 : range.fromUtime) != null ? subscriber.oldTransactions(this._address, range).merge(subscriber.transactions(this._address)) : subscriber.transactions(this.address)).flatMap(item => item.transactions).takeWhile(item => range == null || (range.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) && (range.fromUtime == null || item.createdAt > range.fromUtime) && (range.toLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) && (range.toUtime == null || item.createdAt < range.toUtime)).flatMap(tx => this.decodeTransactionEvents({\n      transaction: tx\n    }).then(events => {\n      events.forEach(event => event.transaction = tx);\n      return events;\n    })).filterMap(async event => {\n      if (filterFn == null || (await filterFn(event))) {\n        return event;\n      } else {\n        return undefined;\n      }\n    }).first();\n    hasTempSubscriber && (await subscriber.unsubscribe());\n    return event;\n  }\n  async getPastEvents(args) {\n    const {\n      range,\n      filter,\n      limit\n    } = args;\n    const filterFn = typeof filter === 'string' ? _ref4 => {\n      let {\n        event\n      } = _ref4;\n      return event === filter;\n    } : filter;\n    const result = [];\n    let currentContinuation = args === null || args === void 0 ? void 0 : args.continuation;\n    outer: while (true) {\n      const {\n        transactions,\n        continuation\n      } = await this._provider.getTransactions({\n        address: this._address,\n        continuation: currentContinuation\n      });\n      if (transactions.length === null) {\n        break;\n      }\n      const filteredTransactions = transactions.filter(item => ((range === null || range === void 0 ? void 0 : range.fromLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) && ((range === null || range === void 0 ? void 0 : range.fromUtime) == null || item.createdAt > range.fromUtime) && ((range === null || range === void 0 ? void 0 : range.toLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) && ((range === null || range === void 0 ? void 0 : range.toUtime) == null || item.createdAt < range.toUtime));\n      if (filteredTransactions.length > 0) {\n        const parsedEvents = await Promise.all(filteredTransactions.map(async tx => {\n          return {\n            tx,\n            events: await this.decodeTransactionEvents({\n              transaction: tx\n            }).then(events => {\n              events.forEach(event => event.transaction = tx);\n              return events;\n            })\n          };\n        }));\n        for (let {\n          tx,\n          events\n        } of parsedEvents) {\n          if (filterFn != null) {\n            events = await Promise.all(events.map(async event => (await filterFn(event)) ? event : undefined)).then(events => events.filter(event => event != null));\n          }\n          currentContinuation = tx.id; // update continuation in case of early break\n          for (const event of events) {\n            if (limit != null && result.length >= limit) {\n              break outer;\n            }\n            result.push(event);\n          }\n          if (limit != null && result.length >= limit) {\n            break outer;\n          }\n        }\n      }\n      currentContinuation = continuation;\n      if (currentContinuation == null) {\n        break;\n      }\n    }\n    return {\n      events: result,\n      continuation: currentContinuation\n    };\n  }\n  async decodeTransaction(args) {\n    await this._provider.ensureInitialized();\n    try {\n      const result = await this._provider.rawApi.decodeTransaction({\n        transaction: (0, models_1.serializeTransaction)(args.transaction),\n        abi: this._abi,\n        method: args.methods\n      });\n      if (result == null) {\n        return undefined;\n      }\n      const {\n        method,\n        input,\n        output\n      } = result;\n      const rawAbi = this.methodsAbi[method];\n      return {\n        method,\n        input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n        output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {}\n      };\n    } catch (_) {\n      return undefined;\n    }\n  }\n  async decodeTransactionEvents(args) {\n    await this._provider.ensureInitialized();\n    try {\n      const {\n        events\n      } = await this._provider.rawApi.decodeTransactionEvents({\n        transaction: (0, models_1.serializeTransaction)(args.transaction),\n        abi: this._abi\n      });\n      const result = [];\n      for (const {\n        event,\n        data\n      } of events) {\n        const rawAbi = this.eventsAbi[event];\n        result.push({\n          event,\n          data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {}\n        });\n      }\n      return result;\n    } catch (_) {\n      return [];\n    }\n  }\n  async decodeInputMessage(args) {\n    await this._provider.ensureInitialized();\n    try {\n      const result = await this._provider.rawApi.decodeInput({\n        abi: this._abi,\n        body: args.body,\n        internal: args.internal,\n        method: args.methods\n      });\n      if (result == null) {\n        return undefined;\n      }\n      const {\n        method,\n        input\n      } = result;\n      const rawAbi = this.methodsAbi[method];\n      return {\n        method,\n        input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {}\n      };\n    } catch (_) {\n      return undefined;\n    }\n  }\n  async decodeOutputMessage(args) {\n    await this._provider.ensureInitialized();\n    try {\n      const result = await this._provider.rawApi.decodeOutput({\n        abi: this._abi,\n        body: args.body,\n        method: args.methods\n      });\n      if (result == null) {\n        return undefined;\n      }\n      const {\n        method,\n        output\n      } = result;\n      const rawAbi = this.methodsAbi[method];\n      return {\n        method,\n        output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {}\n      };\n    } catch (_) {\n      return undefined;\n    }\n  }\n  async decodeEvent(args) {\n    await this._provider.ensureInitialized();\n    try {\n      const result = await this._provider.rawApi.decodeEvent({\n        abi: this.abi,\n        body: args.body,\n        event: args.events\n      });\n      if (result == null) {\n        return undefined;\n      }\n      const {\n        event,\n        data\n      } = result;\n      const rawAbi = this.eventsAbi[event];\n      return {\n        event,\n        data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {}\n      };\n    } catch (_) {\n      return undefined;\n    }\n  }\n}\nexports.Contract = Contract;\n/**\n * @category Contract\n */\nclass TvmException extends Error {\n  constructor(code) {\n    super(`TvmException: ${code}`);\n    this.code = code;\n  }\n}\nexports.TvmException = TvmException;\nclass ContractMethodImpl {\n  constructor(provider, functionAbi, abi, address, method, params) {\n    this.provider = provider;\n    this.functionAbi = functionAbi;\n    this.abi = abi;\n    this.address = address;\n    this.method = method;\n    this.params = (0, models_1.serializeTokensObject)(params);\n  }\n  async send(args) {\n    await this.provider.ensureInitialized();\n    const {\n      transaction\n    } = await this.provider.rawApi.sendMessage({\n      sender: args.from.toString(),\n      recipient: this.address.toString(),\n      amount: args.amount,\n      bounce: args.bounce == null ? true : args.bounce,\n      payload: {\n        abi: this.abi,\n        method: this.method,\n        params: this.params\n      },\n      stateInit: args.stateInit\n    });\n    return (0, models_1.parseTransaction)(transaction);\n  }\n  async sendDelayed(args) {\n    await this.provider.ensureInitialized();\n    const transactions = new utils_1.DelayedTransactions();\n    const subscription = await this.provider.subscribe('messageStatusUpdated');\n    subscription.on('data', data => {\n      if (!data.address.equals(args.from)) {\n        return;\n      }\n      transactions.fillTransaction(data.hash, data.transaction);\n    });\n    const {\n      message\n    } = await this.provider.rawApi.sendMessageDelayed({\n      sender: args.from.toString(),\n      recipient: this.address.toString(),\n      amount: args.amount,\n      bounce: args.bounce == null ? true : args.bounce,\n      payload: {\n        abi: this.abi,\n        method: this.method,\n        params: this.params\n      },\n      stateInit: args.stateInit\n    }).catch(e => {\n      subscription.unsubscribe().catch(console.error);\n      throw e;\n    });\n    const transaction = transactions.waitTransaction(this.address, message.hash).finally(() => subscription.unsubscribe().catch(console.error));\n    return {\n      messageHash: message.hash,\n      expireAt: message.expireAt,\n      transaction\n    };\n  }\n  async sendWithResult(args) {\n    await this.provider.ensureInitialized();\n    let subscriber = args.subscriber;\n    const hasTempSubscriber = subscriber == null;\n    if (subscriber == null) {\n      subscriber = new this.provider.Subscriber();\n    }\n    try {\n      // Parent transaction from wallet\n      let parentTransaction = undefined;\n      // Child transaction promise\n      let resolveChildTransactionPromise;\n      const childTransactionPromise = new Promise(resolve => {\n        resolveChildTransactionPromise = tx => resolve(tx);\n      });\n      // Array for collecting transactions on target before parent transaction promise resolution\n      const possibleChildren = [];\n      // Subscribe to this account\n      subscriber.transactions(this.address).flatMap(batch => batch.transactions)\n      // Listen only messages from sender\n      .filter(item => {\n        var _a;\n        return ((_a = item.inMessage.src) === null || _a === void 0 ? void 0 : _a.equals(args.from)) || false;\n      }).on(tx => {\n        if (parentTransaction == null) {\n          // If we don't known whether the message was sent just collect all transactions from the sender\n          possibleChildren.push(tx);\n        } else if (parentTransaction.possibleMessages.findIndex(msg => msg.hash == tx.inMessage.hash) >= 0) {\n          // Resolve promise if transaction was found\n          resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(tx);\n        }\n      });\n      // Send message\n      const transaction = await this.send(args);\n      // Extract all outgoing messages from the parent transaction to this contract\n      const possibleMessages = transaction.outMessages.filter(msg => {\n        var _a;\n        return ((_a = msg.dst) === null || _a === void 0 ? void 0 : _a.equals(this.address)) || false;\n      });\n      // Update stream state\n      parentTransaction = {\n        transaction,\n        possibleMessages\n      };\n      // Check whether child transaction was already found\n      const alreadyReceived = possibleChildren.find(tx => {\n        return possibleMessages.findIndex(msg => msg.hash == tx.inMessage.hash) >= 0;\n      });\n      if (alreadyReceived != null) {\n        resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(alreadyReceived);\n      }\n      const childTransaction = await childTransactionPromise;\n      // Parse output\n      let output = undefined;\n      try {\n        const result = await this.provider.rawApi.decodeTransaction({\n          transaction: (0, models_1.serializeTransaction)(childTransaction),\n          abi: this.abi,\n          method: this.method\n        });\n        if (result != null) {\n          output = this.functionAbi.outputs != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, result.output) : {};\n        }\n      } catch (e) {\n        console.error(e);\n      }\n      // Done\n      return {\n        parentTransaction: parentTransaction.transaction,\n        childTransaction,\n        output\n      };\n    } finally {\n      hasTempSubscriber && (await subscriber.unsubscribe());\n    }\n  }\n  async estimateFees(args) {\n    await this.provider.ensureInitialized();\n    const {\n      fees\n    } = await this.provider.rawApi.estimateFees({\n      sender: args.from.toString(),\n      recipient: this.address.toString(),\n      amount: args.amount,\n      payload: {\n        abi: this.abi,\n        method: this.method,\n        params: this.params\n      },\n      stateInit: args.stateInit\n    });\n    return fees;\n  }\n  async sendExternal(args) {\n    await this.provider.ensureInitialized();\n    const method = args.withoutSignature === true ? this.provider.rawApi.sendUnsignedExternalMessage : this.provider.rawApi.sendExternalMessage;\n    const {\n      transaction,\n      output\n    } = await method({\n      publicKey: args.publicKey,\n      recipient: this.address.toString(),\n      stateInit: args.stateInit,\n      payload: {\n        abi: this.abi,\n        method: this.method,\n        params: this.params\n      },\n      local: args.local,\n      executorParams: args.executorParams ? {\n        disableSignatureCheck: args.executorParams.disableSignatureCheck,\n        overrideBalance: args.executorParams.overrideBalance\n      } : undefined\n    });\n    return {\n      transaction: (0, models_1.parseTransaction)(transaction),\n      output: output != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined\n    };\n  }\n  async sendExternalDelayed(args) {\n    await this.provider.ensureInitialized();\n    const transactions = new utils_1.DelayedTransactions();\n    const subscription = await this.provider.subscribe('messageStatusUpdated');\n    subscription.on('data', data => {\n      if (!data.address.equals(this.address)) {\n        return;\n      }\n      transactions.fillTransaction(data.hash, data.transaction);\n    });\n    const {\n      message\n    } = await this.provider.rawApi.sendExternalMessageDelayed({\n      publicKey: args.publicKey,\n      recipient: this.address.toString(),\n      stateInit: args.stateInit,\n      payload: {\n        abi: this.abi,\n        method: this.method,\n        params: this.params\n      }\n    }).catch(e => {\n      subscription.unsubscribe().catch(console.error);\n      throw e;\n    });\n    const transaction = transactions.waitTransaction(this.address, message.hash).finally(() => subscription.unsubscribe().catch(console.error));\n    return {\n      messageHash: message.hash,\n      expireAt: message.expireAt,\n      transaction\n    };\n  }\n  async call() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await this.provider.ensureInitialized();\n    const {\n      output,\n      code\n    } = await this.provider.rawApi.runLocal({\n      address: this.address.toString(),\n      cachedState: args.cachedState,\n      responsible: args.responsible,\n      functionCall: {\n        abi: this.abi,\n        method: this.method,\n        params: this.params\n      }\n    });\n    if (output == null || code != 0) {\n      throw new TvmException(code);\n    } else {\n      return (0, models_1.parseTokensObject)(this.functionAbi.outputs, output);\n    }\n  }\n  /**\n   * Encodes this method as an external message and\n   * executes all transaction phases locally, producing a new state\n   */\n  async executeExternal(args) {\n    await this.provider.ensureInitialized();\n    const {\n      transaction,\n      newState,\n      output\n    } = await this.provider.rawApi.executeLocal({\n      address: this.address.toString(),\n      cachedState: args.cachedState,\n      stateInit: args.stateInit,\n      payload: {\n        abi: this.abi,\n        method: this.method,\n        params: this.params\n      },\n      messageHeader: {\n        type: 'external',\n        publicKey: args.publicKey,\n        withoutSignature: args.withoutSignature\n      },\n      executorParams: args.executorParams != null ? {\n        disableSignatureCheck: args.executorParams.disableSignatureCheck,\n        overrideBalance: args.executorParams.overrideBalance\n      } : undefined\n    });\n    return {\n      transaction: (0, models_1.parseTransaction)(transaction),\n      newState,\n      output: output !== undefined ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined\n    };\n  }\n  /**\n   * Encodes this method as an internal message and\n   * executes all transaction phases locally, producing a new state\n   */\n  async executeInternal(args) {\n    await this.provider.ensureInitialized();\n    const {\n      transaction,\n      newState,\n      output\n    } = await this.provider.rawApi.executeLocal({\n      address: this.address.toString(),\n      cachedState: args.cachedState,\n      stateInit: args.stateInit,\n      payload: {\n        abi: this.abi,\n        method: this.method,\n        params: this.params\n      },\n      messageHeader: {\n        type: 'internal',\n        sender: args.sender.toString(),\n        amount: args.amount,\n        bounce: args.bounce != null ? args.bounce : false,\n        bounced: args.bounced\n      },\n      executorParams: args.executorParams != null ? {\n        disableSignatureCheck: args.executorParams.disableSignatureCheck,\n        overrideBalance: args.executorParams.overrideBalance\n      } : undefined\n    });\n    return {\n      transaction: (0, models_1.parseTransaction)(transaction),\n      newState,\n      output: output !== undefined ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined\n    };\n  }\n  async encodeInternal() {\n    await this.provider.ensureInitialized();\n    const {\n      boc\n    } = await this.provider.rawApi.encodeInternalInput({\n      abi: this.abi,\n      method: this.method,\n      params: this.params\n    });\n    return boc;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TvmException","Contract","utils_1","require","models_1","constructor","provider","abi","address","_this","Array","isArray","functions","Error","events","_provider","_abi","JSON","stringify","methodsAbi","reduce","item","inputs","outputs","name","eventsAbi","fieldsAbi","fields","_address","_methods","Proxy","get","_object","method","rawAbi","params","arguments","length","undefined","ContractMethodImpl","_fields","field","ensureInitialized","state","rawApi","getContractFields","toString","cachedState","allowPartial","isDeployed","parsedFields","parseTokensObject","prototype","hasOwnProperty","call","methods","getFullState","getFullContractState","getFields","args","transactions","subscriber","flatMap","_ref","_ref2","tx","decodeTransactionEvents","transaction","then","forEach","event","waitForEvent","range","filter","filterFn","_ref3","hasTempSubscriber","Subscriber","fromLt","fromUtime","oldTransactions","merge","takeWhile","LT_COLLATOR","compare","id","lt","createdAt","toLt","toUtime","filterMap","first","unsubscribe","getPastEvents","limit","_ref4","result","currentContinuation","continuation","outer","getTransactions","filteredTransactions","parsedEvents","Promise","all","map","push","decodeTransaction","serializeTransaction","input","output","_","data","decodeInputMessage","decodeInput","body","internal","decodeOutputMessage","decodeOutput","decodeEvent","code","functionAbi","serializeTokensObject","send","sendMessage","sender","from","recipient","amount","bounce","payload","stateInit","parseTransaction","sendDelayed","DelayedTransactions","subscription","subscribe","on","equals","fillTransaction","hash","message","sendMessageDelayed","catch","e","console","error","waitTransaction","finally","messageHash","expireAt","sendWithResult","parentTransaction","resolveChildTransactionPromise","childTransactionPromise","resolve","possibleChildren","batch","_a","inMessage","src","possibleMessages","findIndex","msg","outMessages","dst","alreadyReceived","find","childTransaction","estimateFees","fees","sendExternal","withoutSignature","sendUnsignedExternalMessage","sendExternalMessage","publicKey","local","executorParams","disableSignatureCheck","overrideBalance","sendExternalDelayed","sendExternalMessageDelayed","runLocal","responsible","functionCall","executeExternal","newState","executeLocal","messageHeader","type","executeInternal","bounced","encodeInternal","boc","encodeInternalInput"],"sources":["/home/king/Desktop/venom-connect-main/examples/react/node_modules/everscale-inpage-provider/dist/contract.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TvmException = exports.Contract = void 0;\nconst utils_1 = require(\"./utils\");\nconst models_1 = require(\"./models\");\n/**\n * @category Contract\n */\nclass Contract {\n    constructor(provider, abi, address) {\n        if (!Array.isArray(abi.functions)) {\n            throw new Error('Invalid abi. Functions array required');\n        }\n        if (!Array.isArray(abi.events)) {\n            throw new Error('Invalid abi. Events array required');\n        }\n        this._provider = provider;\n        this._abi = JSON.stringify(abi);\n        this.methodsAbi = abi.functions.reduce((functions, item) => {\n            if (item.inputs == null) {\n                item.inputs = [];\n            }\n            if (item.outputs == null) {\n                item.outputs = [];\n            }\n            functions[item.name] = item;\n            return functions;\n        }, {});\n        this.eventsAbi = abi.events.reduce((events, item) => {\n            if (item.inputs == null) {\n                item.inputs = [];\n            }\n            events[item.name] = item;\n            return events;\n        }, {});\n        this.fieldsAbi = abi.fields;\n        this._address = address;\n        this._methods = new Proxy({}, {\n            get: (_object, method) => {\n                const rawAbi = this.methodsAbi[method];\n                return (params = {}) => new ContractMethodImpl(this._provider, rawAbi, this._abi, this._address, method, params);\n            },\n        });\n        this._fields = new Proxy({}, {\n            get: (_object, field) => {\n                return async (params = {}) => {\n                    await this._provider.ensureInitialized();\n                    const { fields, state } = await this._provider.rawApi.getContractFields({\n                        address: this._address.toString(),\n                        abi: this._abi,\n                        cachedState: params === null || params === void 0 ? void 0 : params.cachedState,\n                        allowPartial: (params === null || params === void 0 ? void 0 : params.allowPartial) == null ? false : params.allowPartial,\n                    });\n                    if (fields == null) {\n                        if (state == null) {\n                            throw new Error('Account does not exist');\n                        }\n                        else if (!state.isDeployed) {\n                            throw new Error('Account is not deployed');\n                        }\n                        else {\n                            throw new Error('Invalid account data');\n                        }\n                    }\n                    const parsedFields = (0, models_1.parseTokensObject)(this.fieldsAbi, fields);\n                    if (parsedFields == null || !Object.prototype.hasOwnProperty.call(parsedFields, field)) {\n                        throw new Error('Unknown field');\n                    }\n                    return parsedFields[field];\n                };\n            },\n        });\n    }\n    get methods() {\n        return this._methods;\n    }\n    get fields() {\n        return this._fields;\n    }\n    get address() {\n        return this._address;\n    }\n    get abi() {\n        return this._abi;\n    }\n    /**\n     * Requests contract data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getFullState() {\n        await this._provider.ensureInitialized();\n        return (await this._provider.rawApi.getFullContractState({\n            address: this.address.toString(),\n        }));\n    }\n    /**\n     * Unpacks all fields from the contract state using the specified ABI\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getFields(args = {}) {\n        await this._provider.ensureInitialized();\n        const { fields, state } = await this._provider.rawApi.getContractFields({\n            address: this.address.toString(),\n            abi: this._abi,\n            cachedState: args.cachedState,\n            allowPartial: args.allowPartial == null ? false : args.allowPartial,\n        });\n        return {\n            fields: fields != null ? (0, models_1.parseTokensObject)(this.fieldsAbi, fields) : undefined,\n            state,\n        };\n    }\n    /**\n     * Creates new contract transactions stream\n     *\n     * @param subscriber\n     */\n    transactions(subscriber) {\n        return subscriber.transactions(this._address).flatMap(({ transactions }) => transactions);\n    }\n    /**\n     * Creates new contract events stream\n     *\n     * @param subscriber\n     */\n    events(subscriber) {\n        return subscriber\n            .transactions(this._address)\n            .flatMap(({ transactions }) => transactions)\n            .flatMap(tx => this.decodeTransactionEvents({ transaction: tx }).then(events => {\n            events.forEach(event => (event.transaction = tx));\n            return events;\n        }));\n    }\n    async waitForEvent(args = {}) {\n        const { range, filter } = args;\n        const filterFn = typeof filter === 'string'\n            ? ({ event }) => event === filter\n            : filter;\n        let subscriber = args.subscriber;\n        const hasTempSubscriber = subscriber == null;\n        if (subscriber == null) {\n            subscriber = new this._provider.Subscriber();\n        }\n        const event = await ((range === null || range === void 0 ? void 0 : range.fromLt) != null || (range === null || range === void 0 ? void 0 : range.fromUtime) != null\n            ? subscriber.oldTransactions(this._address, range).merge(subscriber.transactions(this._address))\n            : subscriber.transactions(this.address))\n            .flatMap(item => item.transactions)\n            .takeWhile(item => range == null ||\n            ((range.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) &&\n                (range.fromUtime == null || item.createdAt > range.fromUtime) &&\n                (range.toLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) &&\n                (range.toUtime == null || item.createdAt < range.toUtime)))\n            .flatMap(tx => this.decodeTransactionEvents({ transaction: tx }).then(events => {\n            events.forEach(event => (event.transaction = tx));\n            return events;\n        }))\n            .filterMap(async (event) => {\n            if (filterFn == null || (await filterFn(event))) {\n                return event;\n            }\n            else {\n                return undefined;\n            }\n        })\n            .first();\n        hasTempSubscriber && (await subscriber.unsubscribe());\n        return event;\n    }\n    async getPastEvents(args) {\n        const { range, filter, limit } = args;\n        const filterFn = typeof filter === 'string'\n            ? ({ event }) => event === filter\n            : filter;\n        const result = [];\n        let currentContinuation = args === null || args === void 0 ? void 0 : args.continuation;\n        outer: while (true) {\n            const { transactions, continuation } = await this._provider.getTransactions({\n                address: this._address,\n                continuation: currentContinuation,\n            });\n            if (transactions.length === null) {\n                break;\n            }\n            const filteredTransactions = transactions.filter(item => ((range === null || range === void 0 ? void 0 : range.fromLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) &&\n                ((range === null || range === void 0 ? void 0 : range.fromUtime) == null || item.createdAt > range.fromUtime) &&\n                ((range === null || range === void 0 ? void 0 : range.toLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) &&\n                ((range === null || range === void 0 ? void 0 : range.toUtime) == null || item.createdAt < range.toUtime));\n            if (filteredTransactions.length > 0) {\n                const parsedEvents = await Promise.all(filteredTransactions.map(async (tx) => {\n                    return {\n                        tx,\n                        events: await this.decodeTransactionEvents({ transaction: tx }).then(events => {\n                            events.forEach(event => (event.transaction = tx));\n                            return events;\n                        }),\n                    };\n                }));\n                for (let { tx, events } of parsedEvents) {\n                    if (filterFn != null) {\n                        events = await Promise.all(events.map(async (event) => ((await filterFn(event)) ? event : undefined))).then(events => events.filter((event) => event != null));\n                    }\n                    currentContinuation = tx.id; // update continuation in case of early break\n                    for (const event of events) {\n                        if (limit != null && result.length >= limit) {\n                            break outer;\n                        }\n                        result.push(event);\n                    }\n                    if (limit != null && result.length >= limit) {\n                        break outer;\n                    }\n                }\n            }\n            currentContinuation = continuation;\n            if (currentContinuation == null) {\n                break;\n            }\n        }\n        return { events: result, continuation: currentContinuation };\n    }\n    async decodeTransaction(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeTransaction({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, input, output } = result;\n            const rawAbi = this.methodsAbi[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeTransactionEvents(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const { events } = await this._provider.rawApi.decodeTransactionEvents({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n            });\n            const result = [];\n            for (const { event, data } of events) {\n                const rawAbi = this.eventsAbi[event];\n                result.push({\n                    event,\n                    data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n                });\n            }\n            return result;\n        }\n        catch (_) {\n            return [];\n        }\n    }\n    async decodeInputMessage(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeInput({\n                abi: this._abi,\n                body: args.body,\n                internal: args.internal,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, input } = result;\n            const rawAbi = this.methodsAbi[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeOutputMessage(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeOutput({\n                abi: this._abi,\n                body: args.body,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { method, output } = result;\n            const rawAbi = this.methodsAbi[method];\n            return {\n                method,\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeEvent(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeEvent({\n                abi: this.abi,\n                body: args.body,\n                event: args.events,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            const { event, data } = result;\n            const rawAbi = this.eventsAbi[event];\n            return {\n                event,\n                data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n}\nexports.Contract = Contract;\n/**\n * @category Contract\n */\nclass TvmException extends Error {\n    constructor(code) {\n        super(`TvmException: ${code}`);\n        this.code = code;\n    }\n}\nexports.TvmException = TvmException;\nclass ContractMethodImpl {\n    constructor(provider, functionAbi, abi, address, method, params) {\n        this.provider = provider;\n        this.functionAbi = functionAbi;\n        this.abi = abi;\n        this.address = address;\n        this.method = method;\n        this.params = (0, models_1.serializeTokensObject)(params);\n    }\n    async send(args) {\n        await this.provider.ensureInitialized();\n        const { transaction } = await this.provider.rawApi.sendMessage({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            bounce: args.bounce == null ? true : args.bounce,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n            stateInit: args.stateInit,\n        });\n        return (0, models_1.parseTransaction)(transaction);\n    }\n    async sendDelayed(args) {\n        await this.provider.ensureInitialized();\n        const transactions = new utils_1.DelayedTransactions();\n        const subscription = await this.provider.subscribe('messageStatusUpdated');\n        subscription.on('data', data => {\n            if (!data.address.equals(args.from)) {\n                return;\n            }\n            transactions.fillTransaction(data.hash, data.transaction);\n        });\n        const { message } = await this.provider.rawApi\n            .sendMessageDelayed({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            bounce: args.bounce == null ? true : args.bounce,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n            stateInit: args.stateInit,\n        })\n            .catch(e => {\n            subscription.unsubscribe().catch(console.error);\n            throw e;\n        });\n        const transaction = transactions\n            .waitTransaction(this.address, message.hash)\n            .finally(() => subscription.unsubscribe().catch(console.error));\n        return {\n            messageHash: message.hash,\n            expireAt: message.expireAt,\n            transaction,\n        };\n    }\n    async sendWithResult(args) {\n        await this.provider.ensureInitialized();\n        let subscriber = args.subscriber;\n        const hasTempSubscriber = subscriber == null;\n        if (subscriber == null) {\n            subscriber = new this.provider.Subscriber();\n        }\n        try {\n            // Parent transaction from wallet\n            let parentTransaction = undefined;\n            // Child transaction promise\n            let resolveChildTransactionPromise;\n            const childTransactionPromise = new Promise(resolve => {\n                resolveChildTransactionPromise = tx => resolve(tx);\n            });\n            // Array for collecting transactions on target before parent transaction promise resolution\n            const possibleChildren = [];\n            // Subscribe to this account\n            subscriber\n                .transactions(this.address)\n                .flatMap(batch => batch.transactions)\n                // Listen only messages from sender\n                .filter(item => { var _a; return ((_a = item.inMessage.src) === null || _a === void 0 ? void 0 : _a.equals(args.from)) || false; })\n                .on(tx => {\n                if (parentTransaction == null) {\n                    // If we don't known whether the message was sent just collect all transactions from the sender\n                    possibleChildren.push(tx);\n                }\n                else if (parentTransaction.possibleMessages.findIndex(msg => msg.hash == tx.inMessage.hash) >= 0) {\n                    // Resolve promise if transaction was found\n                    resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(tx);\n                }\n            });\n            // Send message\n            const transaction = await this.send(args);\n            // Extract all outgoing messages from the parent transaction to this contract\n            const possibleMessages = transaction.outMessages.filter(msg => { var _a; return ((_a = msg.dst) === null || _a === void 0 ? void 0 : _a.equals(this.address)) || false; });\n            // Update stream state\n            parentTransaction = {\n                transaction,\n                possibleMessages,\n            };\n            // Check whether child transaction was already found\n            const alreadyReceived = possibleChildren.find(tx => {\n                return possibleMessages.findIndex(msg => msg.hash == tx.inMessage.hash) >= 0;\n            });\n            if (alreadyReceived != null) {\n                resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(alreadyReceived);\n            }\n            const childTransaction = await childTransactionPromise;\n            // Parse output\n            let output = undefined;\n            try {\n                const result = await this.provider.rawApi.decodeTransaction({\n                    transaction: (0, models_1.serializeTransaction)(childTransaction),\n                    abi: this.abi,\n                    method: this.method,\n                });\n                if (result != null) {\n                    output = this.functionAbi.outputs != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, result.output) : {};\n                }\n            }\n            catch (e) {\n                console.error(e);\n            }\n            // Done\n            return {\n                parentTransaction: parentTransaction.transaction,\n                childTransaction,\n                output,\n            };\n        }\n        finally {\n            hasTempSubscriber && (await subscriber.unsubscribe());\n        }\n    }\n    async estimateFees(args) {\n        await this.provider.ensureInitialized();\n        const { fees } = await this.provider.rawApi.estimateFees({\n            sender: args.from.toString(),\n            recipient: this.address.toString(),\n            amount: args.amount,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n            stateInit: args.stateInit,\n        });\n        return fees;\n    }\n    async sendExternal(args) {\n        await this.provider.ensureInitialized();\n        const method = args.withoutSignature === true\n            ? this.provider.rawApi.sendUnsignedExternalMessage\n            : this.provider.rawApi.sendExternalMessage;\n        const { transaction, output } = await method({\n            publicKey: args.publicKey,\n            recipient: this.address.toString(),\n            stateInit: args.stateInit,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n            local: args.local,\n            executorParams: args.executorParams\n                ? {\n                    disableSignatureCheck: args.executorParams.disableSignatureCheck,\n                    overrideBalance: args.executorParams.overrideBalance,\n                }\n                : undefined,\n        });\n        return {\n            transaction: (0, models_1.parseTransaction)(transaction),\n            output: output != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,\n        };\n    }\n    async sendExternalDelayed(args) {\n        await this.provider.ensureInitialized();\n        const transactions = new utils_1.DelayedTransactions();\n        const subscription = await this.provider.subscribe('messageStatusUpdated');\n        subscription.on('data', data => {\n            if (!data.address.equals(this.address)) {\n                return;\n            }\n            transactions.fillTransaction(data.hash, data.transaction);\n        });\n        const { message } = await this.provider.rawApi\n            .sendExternalMessageDelayed({\n            publicKey: args.publicKey,\n            recipient: this.address.toString(),\n            stateInit: args.stateInit,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        })\n            .catch(e => {\n            subscription.unsubscribe().catch(console.error);\n            throw e;\n        });\n        const transaction = transactions\n            .waitTransaction(this.address, message.hash)\n            .finally(() => subscription.unsubscribe().catch(console.error));\n        return {\n            messageHash: message.hash,\n            expireAt: message.expireAt,\n            transaction,\n        };\n    }\n    async call(args = {}) {\n        await this.provider.ensureInitialized();\n        const { output, code } = await this.provider.rawApi.runLocal({\n            address: this.address.toString(),\n            cachedState: args.cachedState,\n            responsible: args.responsible,\n            functionCall: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n        });\n        if (output == null || code != 0) {\n            throw new TvmException(code);\n        }\n        else {\n            return (0, models_1.parseTokensObject)(this.functionAbi.outputs, output);\n        }\n    }\n    /**\n     * Encodes this method as an external message and\n     * executes all transaction phases locally, producing a new state\n     */\n    async executeExternal(args) {\n        await this.provider.ensureInitialized();\n        const { transaction, newState, output } = await this.provider.rawApi.executeLocal({\n            address: this.address.toString(),\n            cachedState: args.cachedState,\n            stateInit: args.stateInit,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n            messageHeader: {\n                type: 'external',\n                publicKey: args.publicKey,\n                withoutSignature: args.withoutSignature,\n            },\n            executorParams: args.executorParams != null\n                ? {\n                    disableSignatureCheck: args.executorParams.disableSignatureCheck,\n                    overrideBalance: args.executorParams.overrideBalance,\n                }\n                : undefined,\n        });\n        return {\n            transaction: (0, models_1.parseTransaction)(transaction),\n            newState,\n            output: output !== undefined ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,\n        };\n    }\n    /**\n     * Encodes this method as an internal message and\n     * executes all transaction phases locally, producing a new state\n     */\n    async executeInternal(args) {\n        await this.provider.ensureInitialized();\n        const { transaction, newState, output } = await this.provider.rawApi.executeLocal({\n            address: this.address.toString(),\n            cachedState: args.cachedState,\n            stateInit: args.stateInit,\n            payload: {\n                abi: this.abi,\n                method: this.method,\n                params: this.params,\n            },\n            messageHeader: {\n                type: 'internal',\n                sender: args.sender.toString(),\n                amount: args.amount,\n                bounce: args.bounce != null ? args.bounce : false,\n                bounced: args.bounced,\n            },\n            executorParams: args.executorParams != null\n                ? {\n                    disableSignatureCheck: args.executorParams.disableSignatureCheck,\n                    overrideBalance: args.executorParams.overrideBalance,\n                }\n                : undefined,\n        });\n        return {\n            transaction: (0, models_1.parseTransaction)(transaction),\n            newState,\n            output: output !== undefined ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,\n        };\n    }\n    async encodeInternal() {\n        await this.provider.ensureInitialized();\n        const { boc } = await this.provider.rawApi.encodeInternalInput({\n            abi: this.abi,\n            method: this.method,\n            params: this.params,\n        });\n        return boc;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}