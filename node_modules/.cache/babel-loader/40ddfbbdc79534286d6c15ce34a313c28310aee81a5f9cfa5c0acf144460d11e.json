{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GqlSocket = void 0;\nconst core_1 = __importDefault(require(\"../../core\"));\nconst {\n  nekoton,\n  fetch,\n  fetchAgent,\n  debugLog\n} = core_1.default;\nclass GqlSocket {\n  async connect(clock, params) {\n    class GqlSender {\n      constructor(params) {\n        this.nextLatencyDetectionTime = 0;\n        this.local = params.local === true;\n        this.maxLatency = params.maxLatency || 60000;\n        this.latencyDetectionInterval = params.latencyDetectionInterval || 60000;\n        this.endpoints = params.endpoints.map(GqlSocket.expandAddress);\n        if (this.endpoints.length == 1) {\n          this.currentEndpoint = this.endpoints[0];\n          this.nextLatencyDetectionTime = Number.MAX_VALUE;\n        }\n      }\n      isLocal() {\n        return this.local;\n      }\n      send(data, handler, _longQuery) {\n        (async () => {\n          const now = Date.now();\n          try {\n            let endpoint;\n            if (this.currentEndpoint != null && now < this.nextLatencyDetectionTime) {\n              // Default route\n              endpoint = this.currentEndpoint;\n            } else if (this.resolutionPromise != null) {\n              // Already resolving\n              endpoint = await this.resolutionPromise;\n              delete this.resolutionPromise;\n            } else {\n              delete this.currentEndpoint;\n              // Start resolving (current endpoint is null, or it is time to refresh)\n              this.resolutionPromise = this._selectQueryingEndpoint().then(endpoint => {\n                this.currentEndpoint = endpoint;\n                this.nextLatencyDetectionTime = Date.now() + this.latencyDetectionInterval;\n                return endpoint;\n              });\n              endpoint = await this.resolutionPromise;\n              delete this.resolutionPromise;\n            }\n            const response = await fetch(endpoint.url, {\n              method: 'post',\n              headers: DEFAULT_HEADERS,\n              body: data,\n              agent: endpoint.agent\n            }).then(response => response.text());\n            handler.onReceive(response);\n          } catch (e) {\n            handler.onError(e);\n          }\n        })();\n      }\n      async _selectQueryingEndpoint() {\n        const maxLatency = this.maxLatency;\n        const endpointCount = this.endpoints.length;\n        for (let retryCount = 0; retryCount < 5; ++retryCount) {\n          let handlers;\n          const promise = new Promise((resolve, reject) => {\n            handlers = {\n              resolve: endpoint => resolve(endpoint),\n              reject: () => reject(undefined)\n            };\n          });\n          let checkedEndpoints = 0;\n          let lastLatency;\n          for (const endpoint of this.endpoints) {\n            GqlSocket.checkLatency(endpoint).then(latency => {\n              ++checkedEndpoints;\n              if (latency !== undefined && latency <= maxLatency) {\n                return handlers.resolve(endpoint);\n              }\n              if (lastLatency === undefined || lastLatency.latency === undefined || latency !== undefined && latency < lastLatency.latency) {\n                lastLatency = {\n                  endpoint,\n                  latency\n                };\n              }\n              if (checkedEndpoints >= endpointCount) {\n                if ((lastLatency === null || lastLatency === void 0 ? void 0 : lastLatency.latency) !== undefined) {\n                  handlers.resolve(lastLatency.endpoint);\n                } else {\n                  handlers.reject();\n                }\n              }\n            });\n          }\n          try {\n            return await promise;\n          } catch (e) {\n            let resolveDelay;\n            const delayPromise = new Promise(resolve => {\n              resolveDelay = () => resolve();\n            });\n            setTimeout(() => resolveDelay(), Math.min(100 * retryCount, 5000));\n            await delayPromise;\n          }\n        }\n        throw new Error('Not available endpoint found');\n      }\n    }\n    return new nekoton.GqlConnection(clock, new GqlSender(params));\n  }\n  static async checkLatency(endpoint) {\n    const response = await fetch(`${endpoint.url}?query=%7Binfo%7Bversion%20time%20latency%7D%7D`, {\n      method: 'get',\n      agent: endpoint.agent\n    }).then(response => response.json()).catch(e => {\n      debugLog(e);\n      return undefined;\n    });\n    if (typeof response !== 'object' || response == null) {\n      return;\n    }\n    const data = response['data'];\n    if (typeof data !== 'object' || data == null) {\n      return;\n    }\n    const info = data['info'];\n    if (typeof info !== 'object' || info == null) {\n      return;\n    }\n    const latency = info['latency'];\n    if (typeof latency !== 'number') {\n      return;\n    }\n    return latency;\n  }\n}\nexports.GqlSocket = GqlSocket;\nGqlSocket.expandAddress = baseUrl => {\n  const lastBackslashIndex = baseUrl.lastIndexOf('/');\n  baseUrl = lastBackslashIndex < 0 ? baseUrl : baseUrl.substring(0, lastBackslashIndex);\n  let url;\n  if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {\n    url = `${baseUrl}/graphql`;\n  } else if (['localhost', '127.0.0.1'].indexOf(baseUrl) >= 0) {\n    url = `http://${baseUrl}/graphql`;\n  } else {\n    url = `https://${baseUrl}/graphql`;\n  }\n  return {\n    url,\n    agent: fetchAgent(url)\n  };\n};\nconst DEFAULT_HEADERS = {\n  'Content-Type': 'application/json'\n};","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","GqlSocket","core_1","require","nekoton","fetch","fetchAgent","debugLog","default","connect","clock","params","GqlSender","constructor","nextLatencyDetectionTime","local","maxLatency","latencyDetectionInterval","endpoints","map","expandAddress","length","currentEndpoint","Number","MAX_VALUE","isLocal","send","data","handler","_longQuery","now","Date","endpoint","resolutionPromise","_selectQueryingEndpoint","then","response","url","method","headers","DEFAULT_HEADERS","body","agent","text","onReceive","e","onError","endpointCount","retryCount","handlers","promise","Promise","resolve","reject","undefined","checkedEndpoints","lastLatency","checkLatency","latency","resolveDelay","delayPromise","setTimeout","Math","min","Error","GqlConnection","json","catch","info","baseUrl","lastBackslashIndex","lastIndexOf","substring","startsWith","indexOf"],"sources":["/home/king/Desktop/venom-connect-main/examples/react/node_modules/everscale-standalone-client/client/ConnectionController/gql.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GqlSocket = void 0;\nconst core_1 = __importDefault(require(\"../../core\"));\nconst { nekoton, fetch, fetchAgent, debugLog } = core_1.default;\nclass GqlSocket {\n    async connect(clock, params) {\n        class GqlSender {\n            constructor(params) {\n                this.nextLatencyDetectionTime = 0;\n                this.local = params.local === true;\n                this.maxLatency = params.maxLatency || 60000;\n                this.latencyDetectionInterval = params.latencyDetectionInterval || 60000;\n                this.endpoints = params.endpoints.map(GqlSocket.expandAddress);\n                if (this.endpoints.length == 1) {\n                    this.currentEndpoint = this.endpoints[0];\n                    this.nextLatencyDetectionTime = Number.MAX_VALUE;\n                }\n            }\n            isLocal() {\n                return this.local;\n            }\n            send(data, handler, _longQuery) {\n                (async () => {\n                    const now = Date.now();\n                    try {\n                        let endpoint;\n                        if (this.currentEndpoint != null && now < this.nextLatencyDetectionTime) {\n                            // Default route\n                            endpoint = this.currentEndpoint;\n                        }\n                        else if (this.resolutionPromise != null) {\n                            // Already resolving\n                            endpoint = await this.resolutionPromise;\n                            delete this.resolutionPromise;\n                        }\n                        else {\n                            delete this.currentEndpoint;\n                            // Start resolving (current endpoint is null, or it is time to refresh)\n                            this.resolutionPromise = this._selectQueryingEndpoint().then(endpoint => {\n                                this.currentEndpoint = endpoint;\n                                this.nextLatencyDetectionTime = Date.now() + this.latencyDetectionInterval;\n                                return endpoint;\n                            });\n                            endpoint = await this.resolutionPromise;\n                            delete this.resolutionPromise;\n                        }\n                        const response = await fetch(endpoint.url, {\n                            method: 'post',\n                            headers: DEFAULT_HEADERS,\n                            body: data,\n                            agent: endpoint.agent,\n                        }).then(response => response.text());\n                        handler.onReceive(response);\n                    }\n                    catch (e) {\n                        handler.onError(e);\n                    }\n                })();\n            }\n            async _selectQueryingEndpoint() {\n                const maxLatency = this.maxLatency;\n                const endpointCount = this.endpoints.length;\n                for (let retryCount = 0; retryCount < 5; ++retryCount) {\n                    let handlers;\n                    const promise = new Promise((resolve, reject) => {\n                        handlers = {\n                            resolve: (endpoint) => resolve(endpoint),\n                            reject: () => reject(undefined),\n                        };\n                    });\n                    let checkedEndpoints = 0;\n                    let lastLatency;\n                    for (const endpoint of this.endpoints) {\n                        GqlSocket.checkLatency(endpoint).then(latency => {\n                            ++checkedEndpoints;\n                            if (latency !== undefined && latency <= maxLatency) {\n                                return handlers.resolve(endpoint);\n                            }\n                            if (lastLatency === undefined ||\n                                lastLatency.latency === undefined ||\n                                (latency !== undefined && latency < lastLatency.latency)) {\n                                lastLatency = { endpoint, latency };\n                            }\n                            if (checkedEndpoints >= endpointCount) {\n                                if ((lastLatency === null || lastLatency === void 0 ? void 0 : lastLatency.latency) !== undefined) {\n                                    handlers.resolve(lastLatency.endpoint);\n                                }\n                                else {\n                                    handlers.reject();\n                                }\n                            }\n                        });\n                    }\n                    try {\n                        return await promise;\n                    }\n                    catch (e) {\n                        let resolveDelay;\n                        const delayPromise = new Promise(resolve => {\n                            resolveDelay = () => resolve();\n                        });\n                        setTimeout(() => resolveDelay(), Math.min(100 * retryCount, 5000));\n                        await delayPromise;\n                    }\n                }\n                throw new Error('Not available endpoint found');\n            }\n        }\n        return new nekoton.GqlConnection(clock, new GqlSender(params));\n    }\n    static async checkLatency(endpoint) {\n        const response = (await fetch(`${endpoint.url}?query=%7Binfo%7Bversion%20time%20latency%7D%7D`, {\n            method: 'get',\n            agent: endpoint.agent,\n        })\n            .then(response => response.json())\n            .catch((e) => {\n            debugLog(e);\n            return undefined;\n        }));\n        if (typeof response !== 'object' || response == null) {\n            return;\n        }\n        const data = response['data'];\n        if (typeof data !== 'object' || data == null) {\n            return;\n        }\n        const info = data['info'];\n        if (typeof info !== 'object' || info == null) {\n            return;\n        }\n        const latency = info['latency'];\n        if (typeof latency !== 'number') {\n            return;\n        }\n        return latency;\n    }\n}\nexports.GqlSocket = GqlSocket;\nGqlSocket.expandAddress = (baseUrl) => {\n    const lastBackslashIndex = baseUrl.lastIndexOf('/');\n    baseUrl = lastBackslashIndex < 0 ? baseUrl : baseUrl.substring(0, lastBackslashIndex);\n    let url;\n    if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {\n        url = `${baseUrl}/graphql`;\n    }\n    else if (['localhost', '127.0.0.1'].indexOf(baseUrl) >= 0) {\n        url = `http://${baseUrl}/graphql`;\n    }\n    else {\n        url = `https://${baseUrl}/graphql`;\n    }\n    return {\n        url,\n        agent: fetchAgent(url),\n    };\n};\nconst DEFAULT_HEADERS = {\n    'Content-Type': 'application/json',\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}