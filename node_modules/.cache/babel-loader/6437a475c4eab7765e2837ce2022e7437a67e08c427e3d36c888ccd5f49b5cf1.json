{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EverscaleStandaloneClient = exports.SUPPORTED_PERMISSIONS = exports.VERSION = exports.Clock = exports.SimpleKeystore = exports.checkConnection = exports.ConnectionError = exports.NETWORK_PRESETS = void 0;\nconst fast_safe_stringify_1 = __importDefault(require(\"fast-safe-stringify\"));\nconst core_1 = __importDefault(require(\"../core\"));\nconst utils_1 = require(\"./utils\");\nconst ConnectionController_1 = require(\"./ConnectionController\");\nconst SubscriptionController_1 = require(\"./SubscriptionController\");\nconst AccountsStorage_1 = require(\"./AccountsStorage\");\nvar ConnectionController_2 = require(\"./ConnectionController\");\nObject.defineProperty(exports, \"NETWORK_PRESETS\", {\n  enumerable: true,\n  get: function () {\n    return ConnectionController_2.NETWORK_PRESETS;\n  }\n});\nvar ConnectionController_3 = require(\"./ConnectionController\");\nObject.defineProperty(exports, \"ConnectionError\", {\n  enumerable: true,\n  get: function () {\n    return ConnectionController_3.ConnectionError;\n  }\n});\nObject.defineProperty(exports, \"checkConnection\", {\n  enumerable: true,\n  get: function () {\n    return ConnectionController_3.checkConnection;\n  }\n});\n__exportStar(require(\"./AccountsStorage\"), exports);\nvar keystore_1 = require(\"./keystore\");\nObject.defineProperty(exports, \"SimpleKeystore\", {\n  enumerable: true,\n  get: function () {\n    return keystore_1.SimpleKeystore;\n  }\n});\nvar clock_1 = require(\"./clock\");\nObject.defineProperty(exports, \"Clock\", {\n  enumerable: true,\n  get: function () {\n    return clock_1.Clock;\n  }\n});\nconst {\n  ensureNekotonLoaded,\n  nekoton\n} = core_1.default;\nfunction validateMessageProperties(message) {\n  const m = message || {};\n  return {\n    retryCount: m.retryCount != null ? Math.max(1, ~~m.retryCount) : 5,\n    timeout: m.timeout != null ? Math.max(1, ~~m.timeout) : 60,\n    timeoutGrowFactor: m.timeoutGrowFactor || 1.2,\n    retryTransfers: true\n  };\n}\n/**\n * @category Client\n */\nexports.VERSION = '0.2.25';\n/**\n * @category Client\n */\nexports.SUPPORTED_PERMISSIONS = ['basic', 'accountInteraction'];\n/**\n * @category Client\n */\nclass EverscaleStandaloneClient extends utils_1.SafeEventEmitter {\n  static async create() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await ensureNekotonLoaded(params.initInput);\n    // NOTE: capture client inside notify using wrapper object\n    const notificationContext = {};\n    const notify = (method, params) => {\n      var _a;\n      (_a = notificationContext.client) === null || _a === void 0 ? void 0 : _a.emit(method, params);\n    };\n    const clock = new core_1.default.nekoton.ClockWithOffset();\n    if (params.clock != null) {\n      params.clock['impls'].push(clock);\n      clock.updateOffset(params.clock.offset);\n    }\n    try {\n      const connectionController = params.connection != null ? await (0, ConnectionController_1.createConnectionController)(clock, params.connection) : undefined;\n      const subscriptionController = connectionController != null ? new SubscriptionController_1.SubscriptionController(connectionController, notify) : undefined;\n      const client = new EverscaleStandaloneClient({\n        permissions: {},\n        connectionController,\n        subscriptionController,\n        properties: {\n          message: validateMessageProperties(params.message)\n        },\n        keystore: params.keystore,\n        accountsStorage: params.accountsStorage,\n        clock,\n        notify\n      });\n      // NOTE: WeakRef is not working here, so hope it will be garbage collected\n      notificationContext.client = client;\n      return client;\n    } catch (e) {\n      if (params.clock != null) {\n        params.clock['impls'].pop();\n      }\n      clock.free();\n      throw e;\n    }\n  }\n  static setDebugLogger(logger) {\n    core_1.default.debugLog = logger;\n  }\n  constructor(ctx) {\n    super();\n    this._handlers = {\n      requestPermissions,\n      changeAccount,\n      disconnect,\n      subscribe,\n      unsubscribe,\n      unsubscribeAll,\n      getProviderState,\n      getFullContractState,\n      getAccountsByCodeHash,\n      getTransactions,\n      getTransaction,\n      findTransaction,\n      runLocal,\n      executeLocal,\n      getExpectedAddress,\n      getContractFields,\n      unpackInitData,\n      getBocHash,\n      packIntoCell,\n      unpackFromCell,\n      extractPublicKey,\n      codeToTvc,\n      mergeTvc,\n      splitTvc,\n      setCodeSalt,\n      getCodeSalt,\n      encodeInternalInput,\n      decodeInput,\n      decodeOutput,\n      decodeEvent,\n      decodeTransaction,\n      decodeTransactionEvents,\n      verifySignature,\n      sendUnsignedExternalMessage,\n      // addAsset, // not supported\n      signData,\n      signDataRaw,\n      // encryptData, // not supported\n      // decryptData, // not supported\n      // estimateFees, // not supported\n      sendMessage,\n      sendMessageDelayed,\n      sendExternalMessage,\n      sendExternalMessageDelayed\n    };\n    this._context = ctx;\n  }\n  request(req) {\n    const handler = this._handlers[req.method];\n    if (handler == null) {\n      throw invalidRequest(req, `Method '${req.method}' is not supported by standalone provider`);\n    }\n    return handler(this._context, req);\n  }\n  addListener(eventName, listener) {\n    return super.addListener(eventName, listener);\n  }\n  removeListener(eventName, listener) {\n    return super.removeListener(eventName, listener);\n  }\n  on(eventName, listener) {\n    return super.on(eventName, listener);\n  }\n  once(eventName, listener) {\n    return super.once(eventName, listener);\n  }\n  prependListener(eventName, listener) {\n    return super.prependListener(eventName, listener);\n  }\n  prependOnceListener(eventName, listener) {\n    return super.prependOnceListener(eventName, listener);\n  }\n}\nexports.EverscaleStandaloneClient = EverscaleStandaloneClient;\nconst requestPermissions = async (ctx, req) => {\n  requireParams(req);\n  const {\n    permissions\n  } = req.params;\n  requireArray(req, req.params, 'permissions');\n  const newPermissions = {\n    ...ctx.permissions\n  };\n  for (const permission of permissions) {\n    if (permission === 'basic' || permission === 'tonClient') {\n      newPermissions.basic = true;\n    } else if (permission === 'accountInteraction') {\n      if (newPermissions.accountInteraction != null) {\n        continue;\n      }\n      newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);\n    } else {\n      throw invalidRequest(req, `Permission '${permission}' is not supported by standalone provider`);\n    }\n  }\n  ctx.permissions = newPermissions;\n  // NOTE: be sure to return object copy to prevent adding new permissions\n  const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));\n  ctx.notify('permissionsChanged', {\n    permissions: permissionsCopy\n  });\n  return permissionsCopy;\n};\nconst changeAccount = async (ctx, req) => {\n  requireAccountsStorage(req, ctx);\n  const newPermissions = {\n    ...ctx.permissions\n  };\n  newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);\n  ctx.permissions = newPermissions;\n  // NOTE: be sure to return object copy to prevent adding new permissions\n  const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));\n  ctx.notify('permissionsChanged', {\n    permissions: permissionsCopy\n  });\n  return permissionsCopy;\n};\nconst disconnect = async (ctx, _req) => {\n  var _a;\n  ctx.permissions = {};\n  await ((_a = ctx.subscriptionController) === null || _a === void 0 ? void 0 : _a.unsubscribeFromAllContracts());\n  ctx.notify('permissionsChanged', {\n    permissions: {}\n  });\n  return undefined;\n};\nconst subscribe = async (ctx, req) => {\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    address,\n    subscriptions\n  } = req.params;\n  requireString(req, req.params, 'address');\n  requireOptionalObject(req, req.params, 'subscriptions');\n  let repackedAddress;\n  try {\n    repackedAddress = nekoton.repackAddress(address);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n  try {\n    return await ctx.subscriptionController.subscribeToContract(repackedAddress, subscriptions);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst unsubscribe = async (ctx, req) => {\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    address\n  } = req.params;\n  requireString(req, req.params, 'address');\n  let repackedAddress;\n  try {\n    repackedAddress = nekoton.repackAddress(address);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n  await ctx.subscriptionController.unsubscribeFromContract(repackedAddress);\n  return undefined;\n};\nconst unsubscribeAll = async (ctx, _req) => {\n  var _a;\n  await ((_a = ctx.subscriptionController) === null || _a === void 0 ? void 0 : _a.unsubscribeFromAllContracts());\n  return undefined;\n};\nconst getProviderState = async (ctx, _req) => {\n  var _a, _b;\n  const transport = (_a = ctx.connectionController) === null || _a === void 0 ? void 0 : _a.initializedTransport;\n  const version = exports.VERSION;\n  return {\n    version,\n    numericVersion: (0, utils_1.convertVersionToInt32)(version),\n    networkId: transport != null ? transport.id : 0,\n    selectedConnection: transport != null ? transport.group : '',\n    supportedPermissions: [...exports.SUPPORTED_PERMISSIONS],\n    permissions: JSON.parse(JSON.stringify(ctx.permissions)),\n    subscriptions: ((_b = ctx.subscriptionController) === null || _b === void 0 ? void 0 : _b.subscriptionStates) || {}\n  };\n};\nconst getFullContractState = async (ctx, req) => {\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    address\n  } = req.params;\n  requireString(req, req.params, 'address');\n  const {\n    connectionController\n  } = ctx;\n  try {\n    return connectionController.use(async _ref => {\n      let {\n        data: {\n          transport\n        }\n      } = _ref;\n      return {\n        state: await transport.getFullContractState(address)\n      };\n    });\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst getAccountsByCodeHash = async (ctx, req) => {\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    codeHash,\n    limit,\n    continuation\n  } = req.params;\n  requireString(req, req.params, 'codeHash');\n  requireOptionalNumber(req, req.params, 'limit');\n  requireOptionalString(req, req.params, 'continuation');\n  const {\n    connectionController\n  } = ctx;\n  try {\n    return connectionController.use(_ref2 => {\n      let {\n        data: {\n          transport\n        }\n      } = _ref2;\n      return transport.getAccountsByCodeHash(codeHash, limit || 50, continuation);\n    });\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst getTransactions = async (ctx, req) => {\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    address,\n    continuation,\n    limit\n  } = req.params;\n  requireString(req, req.params, 'address');\n  requireOptional(req, req.params, 'continuation', requireTransactionId);\n  requireOptionalNumber(req, req.params, 'limit');\n  const {\n    connectionController\n  } = ctx;\n  try {\n    return connectionController.use(_ref3 => {\n      let {\n        data: {\n          transport\n        }\n      } = _ref3;\n      return transport.getTransactions(address, continuation === null || continuation === void 0 ? void 0 : continuation.lt, limit || 50);\n    });\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst getTransaction = async (ctx, req) => {\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    hash\n  } = req.params;\n  requireString(req, req.params, 'hash');\n  const {\n    connectionController\n  } = ctx;\n  try {\n    return {\n      transaction: await connectionController.use(_ref4 => {\n        let {\n          data: {\n            transport\n          }\n        } = _ref4;\n        return transport.getTransaction(hash);\n      })\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst findTransaction = async (ctx, req) => {\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    inMessageHash\n  } = req.params;\n  requireOptional(req, req.params, 'inMessageHash', requireString);\n  const {\n    connectionController\n  } = ctx;\n  // TODO: add more filters\n  if (inMessageHash == null) {\n    return {\n      transaction: undefined\n    };\n  }\n  try {\n    return {\n      transaction: await connectionController.use(_ref5 => {\n        let {\n          data: {\n            transport\n          }\n        } = _ref5;\n        return transport.getDstTransaction(inMessageHash);\n      })\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst runLocal = async (ctx, req) => {\n  requireParams(req);\n  const {\n    address,\n    cachedState,\n    responsible,\n    functionCall,\n    withSignatureId\n  } = req.params;\n  requireString(req, req.params, 'address');\n  requireOptional(req, req.params, 'cachedState', requireContractState);\n  requireOptionalBoolean(req, req.params, 'responsible');\n  requireFunctionCall(req, req.params, 'functionCall');\n  requireOptionalSignatureId(req, req.params, 'withSignatureId');\n  let contractState = cachedState;\n  if (contractState == null) {\n    requireConnection(req, ctx);\n    contractState = await ctx.connectionController.use(async _ref6 => {\n      let {\n        data: {\n          transport\n        }\n      } = _ref6;\n      return transport.getFullContractState(address);\n    });\n  }\n  if (contractState == null) {\n    throw invalidRequest(req, 'Account not found');\n  }\n  if (!contractState.isDeployed || contractState.lastTransactionId == null) {\n    throw invalidRequest(req, 'Account is not deployed');\n  }\n  const signatureId = await computeSignatureId(req, ctx, withSignatureId);\n  try {\n    const {\n      output,\n      code\n    } = nekoton.runLocal(ctx.clock, contractState.boc, functionCall.abi, functionCall.method, functionCall.params, responsible || false, signatureId);\n    return {\n      output,\n      code\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst executeLocal = async (ctx, req) => {\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    address,\n    cachedState,\n    stateInit,\n    payload,\n    executorParams,\n    messageHeader\n  } = req.params;\n  requireString(req, req.params, 'address');\n  requireOptional(req, req.params, 'cachedState', requireContractState);\n  requireOptionalString(req, req.params, 'stateInit');\n  requireOptionalRawFunctionCall(req, req.params, 'payload');\n  requireOptionalObject(req, req.params, 'executorParams');\n  requireObject(req, req.params, 'messageHeader');\n  const {\n    clock,\n    connectionController\n  } = ctx;\n  let repackedAddress;\n  try {\n    repackedAddress = nekoton.repackAddress(address);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n  const now = ~~(clock.nowMs / 1000);\n  const timeout = 60;\n  let message;\n  if (messageHeader.type === 'external') {\n    if (payload == null || typeof payload === 'string') {\n      message = nekoton.createRawExternalMessage(repackedAddress, stateInit, payload, now + timeout).boc;\n    } else if (messageHeader.withoutSignature === true) {\n      message = nekoton.createExternalMessageWithoutSignature(clock, repackedAddress, payload.abi, payload.method, stateInit, payload.params, timeout).boc;\n    } else {\n      let unsignedMessage = nekoton.createExternalMessage(clock, repackedAddress, payload.abi, payload.method, stateInit, payload.params, messageHeader.publicKey, timeout);\n      try {\n        if ((executorParams === null || executorParams === void 0 ? void 0 : executorParams.disableSignatureCheck) === true) {\n          message = unsignedMessage.signFake().boc;\n        } else {\n          requireKeystore(req, ctx);\n          const signatureId = await computeSignatureId(req, ctx);\n          const {\n            keystore\n          } = ctx;\n          const signer = await keystore.getSigner(messageHeader.publicKey);\n          if (signer == null) {\n            throw 'Signer not found for public key';\n          }\n          const signature = await signer.sign(unsignedMessage.hash, signatureId);\n          message = unsignedMessage.sign(signature).boc;\n        }\n      } catch (e) {\n        throw invalidRequest(req, e.toString());\n      } finally {\n        unsignedMessage.free();\n      }\n    }\n  } else if (messageHeader.type === 'internal') {\n    requireString(req, messageHeader, 'sender');\n    requireString(req, messageHeader, 'amount');\n    requireBoolean(req, messageHeader, 'bounce');\n    requireOptionalBoolean(req, messageHeader, 'bounced');\n    const body = payload == null ? undefined : typeof payload === 'string' ? payload : nekoton.encodeInternalInput(payload.abi, payload.method, payload.params);\n    message = nekoton.encodeInternalMessage(messageHeader.sender, repackedAddress, messageHeader.bounce, stateInit, body, messageHeader.amount);\n  } else {\n    throw invalidRequest(req, 'Unknown message type');\n  }\n  try {\n    const [contractState, blockchainConfig, networkDescription] = await connectionController.use(_ref7 => {\n      let {\n        data: {\n          transport\n        }\n      } = _ref7;\n      return Promise.all([cachedState == null ? transport.getFullContractState(repackedAddress) : cachedState, transport.getBlockchainConfig(), transport.getNetworkDescription()]);\n    });\n    const account = nekoton.makeFullAccountBoc(contractState === null || contractState === void 0 ? void 0 : contractState.boc);\n    const overrideBalance = executorParams === null || executorParams === void 0 ? void 0 : executorParams.overrideBalance;\n    const result = nekoton.executeLocal(blockchainConfig, account, message, now, (executorParams === null || executorParams === void 0 ? void 0 : executorParams.disableSignatureCheck) === true, overrideBalance != null ? overrideBalance.toString() : undefined, networkDescription.globalId);\n    if (result.exitCode != null) {\n      throw new Error(`Contract did not accept the message. Exit code: ${result.exitCode}`);\n    }\n    const resultVariant = result;\n    const transaction = resultVariant.transaction;\n    const newState = nekoton.parseFullAccountBoc(resultVariant.account);\n    let output;\n    try {\n      if (typeof payload === 'object' && typeof payload != null) {\n        const decoded = nekoton.decodeTransaction(resultVariant.transaction, payload.abi, payload.method);\n        output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n      }\n    } catch (_) {\n      /* do nothing */\n    }\n    return {\n      transaction,\n      newState,\n      output\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst getExpectedAddress = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    tvc,\n    abi,\n    workchain,\n    publicKey,\n    initParams\n  } = req.params;\n  requireString(req, req.params, 'tvc');\n  requireString(req, req.params, 'abi');\n  requireOptionalNumber(req, req.params, 'workchain');\n  requireOptionalString(req, req.params, 'publicKey');\n  try {\n    return nekoton.getExpectedAddress(tvc, abi, workchain || 0, publicKey, initParams);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst getContractFields = async (ctx, req) => {\n  requireParams(req);\n  const {\n    address,\n    abi,\n    cachedState,\n    allowPartial\n  } = req.params;\n  requireString(req, req.params, 'address');\n  requireString(req, req.params, 'abi');\n  requireOptional(req, req.params, 'cachedState', requireContractState);\n  requireBoolean(req, req.params, 'allowPartial');\n  let repackedAddress;\n  try {\n    repackedAddress = nekoton.repackAddress(address);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n  let contractState = cachedState;\n  if (contractState == null) {\n    requireConnection(req, ctx);\n    contractState = await ctx.connectionController.use(async _ref8 => {\n      let {\n        data: {\n          transport\n        }\n      } = _ref8;\n      return transport.getFullContractState(repackedAddress);\n    });\n  }\n  if (contractState == null) {\n    return {\n      fields: undefined,\n      state: undefined\n    };\n  }\n  if (!contractState.isDeployed || contractState.lastTransactionId == null) {\n    return {\n      fields: undefined,\n      state: contractState\n    };\n  }\n  try {\n    const fields = nekoton.unpackContractFields(abi, contractState.boc, allowPartial);\n    return {\n      fields,\n      state: contractState\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst unpackInitData = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    abi,\n    data\n  } = req.params;\n  requireString(req, req.params, 'abi');\n  requireString(req, req.params, 'data');\n  try {\n    const {\n      publicKey,\n      data: initParams\n    } = nekoton.unpackInitData(abi, data);\n    return {\n      publicKey,\n      initParams\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst getBocHash = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    boc\n  } = req.params;\n  requireString(req, req.params, 'boc');\n  try {\n    return {\n      hash: nekoton.getBocHash(boc)\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst packIntoCell = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    structure,\n    data,\n    abiVersion\n  } = req.params;\n  requireArray(req, req.params, 'structure');\n  requireOptional(req, req.params, 'abiVersion', requireString);\n  try {\n    return nekoton.packIntoCell(structure, data, abiVersion);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst unpackFromCell = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    structure,\n    boc,\n    allowPartial,\n    abiVersion\n  } = req.params;\n  requireArray(req, req.params, 'structure');\n  requireString(req, req.params, 'boc');\n  requireBoolean(req, req.params, 'allowPartial');\n  requireOptional(req, req.params, 'abiVersion', requireString);\n  try {\n    return {\n      data: nekoton.unpackFromCell(structure, boc, allowPartial, abiVersion)\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst extractPublicKey = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    boc\n  } = req.params;\n  requireString(req, req.params, 'boc');\n  try {\n    return {\n      publicKey: nekoton.extractPublicKey(boc)\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst codeToTvc = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    code\n  } = req.params;\n  requireString(req, req.params, 'code');\n  try {\n    const {\n      boc,\n      hash\n    } = nekoton.codeToTvc(code);\n    return {\n      tvc: boc,\n      hash\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst mergeTvc = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    code,\n    data\n  } = req.params;\n  requireString(req, req.params, 'code');\n  requireString(req, req.params, 'data');\n  try {\n    const {\n      boc,\n      hash\n    } = nekoton.mergeTvc(code, data);\n    return {\n      tvc: boc,\n      hash\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst splitTvc = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    tvc\n  } = req.params;\n  requireString(req, req.params, 'tvc');\n  try {\n    return nekoton.splitTvc(tvc);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst setCodeSalt = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    code,\n    salt\n  } = req.params;\n  requireString(req, req.params, 'code');\n  requireString(req, req.params, 'salt');\n  try {\n    const {\n      boc,\n      hash\n    } = nekoton.setCodeSalt(code, salt);\n    return {\n      code: boc,\n      hash\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst getCodeSalt = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    code\n  } = req.params;\n  requireString(req, req.params, 'code');\n  try {\n    return {\n      salt: nekoton.getCodeSalt(code)\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst encodeInternalInput = async (_ctx, req) => {\n  requireParams(req);\n  requireFunctionCall(req, req, 'params');\n  const {\n    abi,\n    method,\n    params\n  } = req.params;\n  try {\n    return {\n      boc: nekoton.encodeInternalInput(abi, method, params)\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst decodeInput = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    body,\n    abi,\n    method,\n    internal\n  } = req.params;\n  requireString(req, req.params, 'body');\n  requireString(req, req.params, 'abi');\n  requireMethodOrArray(req, req.params, 'method');\n  requireBoolean(req, req.params, 'internal');\n  try {\n    return nekoton.decodeInput(body, abi, method, internal) || null;\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst decodeOutput = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    body,\n    abi,\n    method\n  } = req.params;\n  requireString(req, req.params, 'body');\n  requireString(req, req.params, 'abi');\n  requireMethodOrArray(req, req.params, 'method');\n  try {\n    return nekoton.decodeOutput(body, abi, method) || null;\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst decodeEvent = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    body,\n    abi,\n    event\n  } = req.params;\n  requireString(req, req.params, 'body');\n  requireString(req, req.params, 'abi');\n  requireMethodOrArray(req, req.params, 'event');\n  try {\n    return nekoton.decodeEvent(body, abi, event) || null;\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst decodeTransaction = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    transaction,\n    abi,\n    method\n  } = req.params;\n  requireString(req, req.params, 'abi');\n  requireMethodOrArray(req, req.params, 'method');\n  try {\n    return nekoton.decodeTransaction(transaction, abi, method) || null;\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst decodeTransactionEvents = async (_ctx, req) => {\n  requireParams(req);\n  const {\n    transaction,\n    abi\n  } = req.params;\n  requireString(req, req.params, 'abi');\n  try {\n    return {\n      events: nekoton.decodeTransactionEvents(transaction, abi)\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst verifySignature = async (ctx, req) => {\n  requireParams(req);\n  const {\n    publicKey,\n    dataHash,\n    signature,\n    withSignatureId\n  } = req.params;\n  requireString(req, req.params, 'publicKey');\n  requireString(req, req.params, 'dataHash');\n  requireString(req, req.params, 'signature');\n  requireOptionalSignatureId(req, req.params, 'withSignatureId');\n  const signatureId = await computeSignatureId(req, ctx, withSignatureId);\n  try {\n    return {\n      isValid: nekoton.verifySignature(publicKey, dataHash, signature, signatureId)\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst sendUnsignedExternalMessage = async (ctx, req) => {\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    recipient,\n    stateInit,\n    payload,\n    local,\n    executorParams\n  } = req.params;\n  requireString(req, req.params, 'recipient');\n  requireOptionalString(req, req.params, 'stateInit');\n  requireOptionalRawFunctionCall(req, req.params, 'payload');\n  requireOptionalBoolean(req, req.params, 'local');\n  requireOptionalObject(req, req.params, 'executorParams');\n  let repackedRecipient;\n  try {\n    repackedRecipient = nekoton.repackAddress(recipient);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n  const {\n    clock,\n    subscriptionController,\n    properties\n  } = ctx;\n  const makeSignedMessage = timeout => {\n    try {\n      if (typeof payload === 'string' || payload == null) {\n        const expireAt = ~~(clock.nowMs / 1000) + timeout;\n        return nekoton.createRawExternalMessage(repackedRecipient, stateInit, payload, ~~expireAt);\n      } else {\n        return nekoton.createExternalMessageWithoutSignature(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, ~~timeout);\n      }\n    } catch (e) {\n      throw invalidRequest(req, e.toString());\n    }\n  };\n  const handleTransaction = transaction => {\n    let output;\n    try {\n      if (typeof payload === 'object' && typeof payload != null) {\n        const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);\n        output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n      }\n    } catch (_) {\n      /* do nothing */\n    }\n    return {\n      transaction,\n      output\n    };\n  };\n  // Force local execution\n  if (local === true) {\n    const signedMessage = makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage, executorParams);\n    return handleTransaction(transaction);\n  }\n  // Send and wait with several retries\n  let timeout = properties.message.timeout;\n  for (let retry = 0; retry < properties.message.retryCount; ++retry) {\n    const signedMessage = makeSignedMessage(timeout);\n    const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);\n    if (transaction == null) {\n      timeout *= properties.message.timeoutGrowFactor;\n      continue;\n    }\n    return handleTransaction(transaction);\n  }\n  // Execute locally\n  const errorMessage = 'Message expired';\n  const signedMessage = makeSignedMessage(60);\n  const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage).catch(e => {\n    throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n  });\n  const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n  throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst signData = async (ctx, req) => {\n  requireKeystore(req, ctx);\n  requireParams(req);\n  const {\n    publicKey,\n    data,\n    withSignatureId\n  } = req.params;\n  requireString(req, req.params, 'publicKey');\n  requireString(req, req.params, 'data');\n  requireOptionalSignatureId(req, req.params, 'withSignatureId');\n  const signatureId = await computeSignatureId(req, ctx, withSignatureId);\n  const {\n    keystore\n  } = ctx;\n  const signer = await keystore.getSigner(publicKey);\n  if (signer == null) {\n    throw invalidRequest(req, 'Signer not found for public key');\n  }\n  try {\n    const dataHash = nekoton.getDataHash(data);\n    return {\n      dataHash,\n      ...(await signer.sign(dataHash, signatureId).then(nekoton.extendSignature))\n    };\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst signDataRaw = async (ctx, req) => {\n  requireKeystore(req, ctx);\n  requireParams(req);\n  const {\n    publicKey,\n    data,\n    withSignatureId\n  } = req.params;\n  requireString(req, req.params, 'publicKey');\n  requireString(req, req.params, 'data');\n  requireOptionalSignatureId(req, req.params, 'withSignatureId');\n  const signatureId = await computeSignatureId(req, ctx, withSignatureId);\n  const {\n    keystore\n  } = ctx;\n  const signer = await keystore.getSigner(publicKey);\n  if (signer == null) {\n    throw invalidRequest(req, 'Signer not found for public key');\n  }\n  try {\n    return await signer.sign(data, signatureId).then(nekoton.extendSignature);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n};\nconst sendMessage = async (ctx, req) => {\n  requireKeystore(req, ctx);\n  requireAccountsStorage(req, ctx);\n  requireConnection(req, ctx);\n  requireParams(req);\n  const {\n    sender,\n    recipient,\n    amount,\n    bounce,\n    payload,\n    stateInit\n  } = req.params;\n  requireString(req, req.params, 'sender');\n  requireString(req, req.params, 'recipient');\n  requireString(req, req.params, 'amount');\n  requireBoolean(req, req.params, 'bounce');\n  requireOptional(req, req.params, 'payload', requireFunctionCall);\n  requireOptionalString(req, req.params, 'stateInit');\n  const signatureId = await computeSignatureId(req, ctx);\n  const {\n    clock,\n    properties,\n    subscriptionController,\n    connectionController,\n    keystore,\n    accountsStorage\n  } = ctx;\n  let repackedSender;\n  let repackedRecipient;\n  let account;\n  try {\n    repackedSender = nekoton.repackAddress(sender);\n    repackedRecipient = nekoton.repackAddress(recipient);\n    account = await accountsStorage.getAccount(repackedSender).then(account => {\n      if (account != null) {\n        return account;\n      } else {\n        throw new Error('Sender not found');\n      }\n    });\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n  const makeSignedMessage = async timeout => {\n    try {\n      return account.prepareMessage({\n        recipient: repackedRecipient,\n        amount,\n        bounce,\n        payload,\n        stateInit,\n        timeout: ~~timeout,\n        signatureId\n      }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));\n    } catch (e) {\n      throw invalidRequest(req, e.toString());\n    }\n  };\n  // Send and wait with several retries\n  let timeout = properties.message.timeout;\n  // Set `retryCount` if not explicitly disabled\n  const retryCount = properties.message.retryTransfers !== false ? properties.message.retryCount : 1;\n  for (let retry = 0; retry < retryCount; ++retry) {\n    const signedMessage = await makeSignedMessage(timeout);\n    const transaction = await subscriptionController.sendMessage(repackedSender, signedMessage);\n    if (transaction == null) {\n      timeout *= properties.message.timeoutGrowFactor;\n      continue;\n    }\n    return {\n      transaction\n    };\n  }\n  // Execute locally\n  const errorMessage = 'Message expired';\n  const signedMessage = await makeSignedMessage(60);\n  const transaction = await subscriptionController.sendMessageLocally(repackedSender, signedMessage).catch(e => {\n    throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n  });\n  const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n  throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst sendMessageDelayed = async (ctx, req) => {\n  requireKeystore(req, ctx);\n  requireAccountsStorage(req, ctx);\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    sender,\n    recipient,\n    amount,\n    bounce,\n    payload,\n    stateInit\n  } = req.params;\n  requireString(req, req.params, 'sender');\n  requireString(req, req.params, 'recipient');\n  requireString(req, req.params, 'amount');\n  requireBoolean(req, req.params, 'bounce');\n  requireOptional(req, req.params, 'payload', requireFunctionCall);\n  requireOptionalString(req, req.params, 'stateInit');\n  const signatureId = await computeSignatureId(req, ctx);\n  const {\n    clock,\n    subscriptionController,\n    connectionController,\n    keystore,\n    accountsStorage,\n    notify\n  } = ctx;\n  let repackedSender;\n  let repackedRecipient;\n  try {\n    repackedSender = nekoton.repackAddress(sender);\n    repackedRecipient = nekoton.repackAddress(recipient);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n  let signedMessage;\n  try {\n    const account = await accountsStorage.getAccount(repackedSender);\n    if (account == null) {\n      throw new Error('Sender not found');\n    }\n    signedMessage = await account.prepareMessage({\n      recipient: repackedRecipient,\n      amount,\n      bounce,\n      payload,\n      stateInit,\n      timeout: 60,\n      signatureId\n    }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n  subscriptionController.sendMessage(repackedSender, signedMessage).then(transaction => {\n    notify('messageStatusUpdated', {\n      address: repackedSender,\n      hash: signedMessage.hash,\n      transaction\n    });\n  }).catch(console.error);\n  return {\n    message: {\n      account: repackedSender,\n      hash: signedMessage.hash,\n      expireAt: signedMessage.expireAt\n    }\n  };\n};\nconst sendExternalMessage = async (ctx, req) => {\n  requireKeystore(req, ctx);\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    publicKey,\n    recipient,\n    stateInit,\n    payload,\n    local,\n    executorParams\n  } = req.params;\n  requireString(req, req.params, 'publicKey');\n  requireString(req, req.params, 'recipient');\n  requireOptionalString(req, req.params, 'stateInit');\n  requireFunctionCall(req, req.params, 'payload');\n  requireOptionalBoolean(req, req.params, 'local');\n  requireOptionalObject(req, req.params, 'executorParams');\n  const signatureId = await computeSignatureId(req, ctx);\n  let repackedRecipient;\n  try {\n    repackedRecipient = nekoton.repackAddress(recipient);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n  const {\n    clock,\n    subscriptionController,\n    keystore,\n    properties\n  } = ctx;\n  const signer = await keystore.getSigner(publicKey);\n  if (signer == null) {\n    throw invalidRequest(req, 'Signer not found for public key');\n  }\n  const makeSignedMessage = async timeout => {\n    let unsignedMessage;\n    try {\n      unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, ~~timeout);\n    } catch (e) {\n      throw invalidRequest(req, e.toString());\n    }\n    try {\n      const signature = await signer.sign(unsignedMessage.hash, signatureId);\n      return unsignedMessage.sign(signature);\n    } catch (e) {\n      throw invalidRequest(req, e.toString());\n    } finally {\n      unsignedMessage.free();\n    }\n  };\n  const handleTransaction = transaction => {\n    let output;\n    try {\n      const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);\n      output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n    } catch (_) {\n      /* do nothing */\n    }\n    return {\n      transaction,\n      output\n    };\n  };\n  // Force local execution\n  if (local === true) {\n    const signedMessage = await makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage, executorParams);\n    return handleTransaction(transaction);\n  }\n  // Send and wait with several retries\n  let timeout = properties.message.timeout;\n  for (let retry = 0; retry < properties.message.retryCount; ++retry) {\n    const signedMessage = await makeSignedMessage(timeout);\n    const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);\n    if (transaction == null) {\n      timeout *= properties.message.timeoutGrowFactor;\n      continue;\n    }\n    return handleTransaction(transaction);\n  }\n  // Execute locally\n  const errorMessage = 'Message expired';\n  const signedMessage = await makeSignedMessage(60);\n  const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage).catch(e => {\n    throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n  });\n  const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n  throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst sendExternalMessageDelayed = async (ctx, req) => {\n  requireKeystore(req, ctx);\n  requireParams(req);\n  requireConnection(req, ctx);\n  const {\n    publicKey,\n    recipient,\n    stateInit,\n    payload\n  } = req.params;\n  requireString(req, req.params, 'publicKey');\n  requireString(req, req.params, 'recipient');\n  requireOptionalString(req, req.params, 'stateInit');\n  requireFunctionCall(req, req.params, 'payload');\n  const signatureId = await computeSignatureId(req, ctx);\n  let repackedRecipient;\n  try {\n    repackedRecipient = nekoton.repackAddress(recipient);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n  const {\n    clock,\n    subscriptionController,\n    keystore,\n    properties,\n    notify\n  } = ctx;\n  const signer = await keystore.getSigner(publicKey);\n  if (signer == null) {\n    throw invalidRequest(req, 'Signer not found for public key');\n  }\n  let unsignedMessage;\n  try {\n    unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, ~~properties.message.timeout);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  }\n  let signedMessage;\n  try {\n    const signature = await signer.sign(unsignedMessage.hash, signatureId);\n    signedMessage = unsignedMessage.sign(signature);\n  } catch (e) {\n    throw invalidRequest(req, e.toString());\n  } finally {\n    unsignedMessage.free();\n  }\n  subscriptionController.sendMessage(repackedRecipient, signedMessage).then(transaction => {\n    notify('messageStatusUpdated', {\n      address: repackedRecipient,\n      hash: signedMessage.hash,\n      transaction\n    });\n  }).catch(console.error);\n  return {\n    message: {\n      account: repackedRecipient,\n      hash: signedMessage.hash,\n      expireAt: signedMessage.expireAt\n    }\n  };\n};\nfunction requireKeystore(req, context) {\n  if (context.keystore == null) {\n    throw invalidRequest(req, 'Keystore not found');\n  }\n}\nfunction requireAccountsStorage(req, context) {\n  if (context.accountsStorage == null) {\n    throw invalidRequest(req, 'AccountsStorage not found');\n  }\n}\nfunction requireConnection(req, context) {\n  if (context.connectionController == null || context.subscriptionController == null) {\n    throw invalidRequest(req, 'Connection was not initialized');\n  }\n}\nasync function computeSignatureId(req, ctx, withSignatureId) {\n  if (withSignatureId === false) {\n    return undefined;\n  } else if (typeof withSignatureId === 'number') {\n    return withSignatureId;\n  } else if (ctx.connectionController == null) {\n    return undefined;\n  }\n  return ctx.connectionController.use(async _ref9 => {\n    let {\n      data: {\n        transport\n      }\n    } = _ref9;\n    return transport.getSignatureId();\n  }).catch(_ => {\n    throw invalidRequest(req, 'Failed to fetch signature id');\n  });\n}\nfunction requireParams(req) {\n  if (req.params == null || typeof req.params !== 'object') {\n    throw invalidRequest(req, 'required params object');\n  }\n}\nfunction requireObject(req, object, key) {\n  const property = object[key];\n  if (typeof property !== 'object') {\n    throw invalidRequest(req, `'${String(key)}' must be an object`);\n  }\n}\nfunction requireOptionalObject(req, object, key) {\n  const property = object[key];\n  if (property != null && typeof property !== 'object') {\n    throw invalidRequest(req, `'${String(key)}' must be an object if specified`);\n  }\n}\nfunction requireBoolean(req, object, key) {\n  const property = object[key];\n  if (typeof property !== 'boolean') {\n    throw invalidRequest(req, `'${String(key)}' must be a boolean`);\n  }\n}\nfunction requireOptionalBoolean(req, object, key) {\n  const property = object[key];\n  if (property != null && typeof property !== 'boolean') {\n    throw invalidRequest(req, `'${String(key)}' must be a boolean if specified`);\n  }\n}\nfunction requireString(req, object, key) {\n  const property = object[key];\n  if (typeof property !== 'string' || property.length === 0) {\n    throw invalidRequest(req, `'${String(key)}' must be non-empty string`);\n  }\n}\nfunction requireOptionalString(req, object, key) {\n  const property = object[key];\n  if (property != null && (typeof property !== 'string' || property.length === 0)) {\n    throw invalidRequest(req, `'${String(key)}' must be a non-empty string if provided`);\n  }\n}\nfunction requireOptionalNumber(req, object, key) {\n  const property = object[key];\n  if (property != null && typeof property !== 'number') {\n    throw invalidRequest(req, `'${String(key)}' must be a number if provider`);\n  }\n}\nfunction requireArray(req, object, key) {\n  const property = object[key];\n  if (!Array.isArray(property)) {\n    throw invalidRequest(req, `'${String(key)}' must be an array`);\n  }\n}\nfunction requireOptional(req, object, key, predicate) {\n  const property = object[key];\n  if (property != null) {\n    predicate(req, object, key);\n  }\n}\nfunction requireOptionalSignatureId(req, object, key) {\n  const property = object[key];\n  if (property != null) {\n    if (typeof property !== 'boolean' && typeof property !== 'number') {\n      throw invalidRequest(req, `'${String(key)}' must be an optional boolean or number`);\n    }\n  }\n}\nfunction requireTransactionId(req, object, key) {\n  requireObject(req, object, key);\n  const property = object[key];\n  requireString(req, property, 'lt');\n  requireString(req, property, 'hash');\n}\nfunction requireLastTransactionId(req, object, key) {\n  requireObject(req, object, key);\n  const property = object[key];\n  requireBoolean(req, property, 'isExact');\n  requireString(req, property, 'lt');\n  requireOptionalString(req, property, 'hash');\n}\nfunction requireContractState(req, object, key) {\n  requireObject(req, object, key);\n  const property = object[key];\n  requireString(req, property, 'balance');\n  requireOptional(req, property, 'lastTransactionId', requireLastTransactionId);\n  requireBoolean(req, property, 'isDeployed');\n}\nfunction requireFunctionCall(req, object, key) {\n  requireObject(req, object, key);\n  const property = object[key];\n  requireString(req, property, 'abi');\n  requireString(req, property, 'method');\n  requireObject(req, property, 'params');\n}\nfunction requireOptionalRawFunctionCall(req, object, key) {\n  const property = object[key];\n  if (typeof property === 'string' || property == null) {\n    return;\n  } else if (typeof property === 'object') {\n    requireString(req, property, 'abi');\n    requireString(req, property, 'method');\n    requireObject(req, property, 'params');\n  } else {\n    throw invalidRequest(req, `'${String(key)}' must be a function all or optional string`);\n  }\n}\nfunction requireMethodOrArray(req, object, key) {\n  const property = object[key];\n  if (property != null && typeof property !== 'string' && !Array.isArray(property)) {\n    throw invalidRequest(req, `'${String(key)}' must be a method name or an array of possible names`);\n  }\n}\nasync function makeAccountInteractionPermission(req, ctx) {\n  requireAccountsStorage(req, ctx);\n  requireConnection(req, ctx);\n  const defaultAccount = ctx.accountsStorage.defaultAccount;\n  if (defaultAccount == null) {\n    throw invalidRequest(req, 'Default account not set in accounts storage');\n  }\n  const account = await ctx.accountsStorage.getAccount(defaultAccount);\n  if (account == null) {\n    throw invalidRequest(req, 'Default account not found');\n  }\n  const publicKey = await account.fetchPublicKey(new AccountsStorage_1.AccountsStorageContext(ctx.clock, ctx.connectionController, nekoton));\n  return {\n    address: account.address.toString(),\n    publicKey,\n    contractType: 'unknown'\n  };\n}\nconst invalidRequest = (req, message, data) => new NekotonRpcError(2, `${req.method}: ${message}`, data);\nclass NekotonRpcError extends Error {\n  constructor(code, message, data) {\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer');\n    }\n    if (!message || typeof message !== 'string') {\n      throw new Error('\"message\" must be a nonempty string');\n    }\n    super(message);\n    this.code = code;\n    this.data = data;\n  }\n  serialize() {\n    const serialized = {\n      code: this.code,\n      message: this.message\n    };\n    if (this.data !== undefined) {\n      serialized.data = this.data;\n    }\n    if (this.stack) {\n      serialized.stack = this.stack;\n    }\n    return serialized;\n  }\n  toString() {\n    return (0, fast_safe_stringify_1.default)(this.serialize(), stringifyReplacer, 2);\n  }\n}\nconst stringifyReplacer = (_, value) => {\n  if (value === '[Circular]') {\n    return undefined;\n  }\n  return value;\n};","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__exportStar","exports","p","prototype","hasOwnProperty","call","__importDefault","mod","value","EverscaleStandaloneClient","SUPPORTED_PERMISSIONS","VERSION","Clock","SimpleKeystore","checkConnection","ConnectionError","NETWORK_PRESETS","fast_safe_stringify_1","require","core_1","utils_1","ConnectionController_1","SubscriptionController_1","AccountsStorage_1","ConnectionController_2","ConnectionController_3","keystore_1","clock_1","ensureNekotonLoaded","nekoton","default","validateMessageProperties","message","retryCount","Math","max","timeout","timeoutGrowFactor","retryTransfers","SafeEventEmitter","params","arguments","length","initInput","notificationContext","notify","method","_a","client","emit","clock","ClockWithOffset","push","updateOffset","offset","connectionController","connection","createConnectionController","subscriptionController","SubscriptionController","permissions","properties","keystore","accountsStorage","e","pop","free","setDebugLogger","logger","debugLog","constructor","ctx","_handlers","requestPermissions","changeAccount","disconnect","subscribe","unsubscribe","unsubscribeAll","getProviderState","getFullContractState","getAccountsByCodeHash","getTransactions","getTransaction","findTransaction","runLocal","executeLocal","getExpectedAddress","getContractFields","unpackInitData","getBocHash","packIntoCell","unpackFromCell","extractPublicKey","codeToTvc","mergeTvc","splitTvc","setCodeSalt","getCodeSalt","encodeInternalInput","decodeInput","decodeOutput","decodeEvent","decodeTransaction","decodeTransactionEvents","verifySignature","sendUnsignedExternalMessage","signData","signDataRaw","sendMessage","sendMessageDelayed","sendExternalMessage","sendExternalMessageDelayed","_context","request","req","handler","invalidRequest","addListener","eventName","listener","removeListener","on","once","prependListener","prependOnceListener","requireParams","requireArray","newPermissions","permission","basic","accountInteraction","makeAccountInteractionPermission","permissionsCopy","JSON","parse","stringify","requireAccountsStorage","_req","unsubscribeFromAllContracts","requireConnection","address","subscriptions","requireString","requireOptionalObject","repackedAddress","repackAddress","toString","subscribeToContract","unsubscribeFromContract","_b","transport","initializedTransport","version","numericVersion","convertVersionToInt32","networkId","id","selectedConnection","group","supportedPermissions","subscriptionStates","use","_ref","data","state","codeHash","limit","continuation","requireOptionalNumber","requireOptionalString","_ref2","requireOptional","requireTransactionId","_ref3","lt","hash","transaction","_ref4","inMessageHash","_ref5","getDstTransaction","cachedState","responsible","functionCall","withSignatureId","requireContractState","requireOptionalBoolean","requireFunctionCall","requireOptionalSignatureId","contractState","_ref6","isDeployed","lastTransactionId","signatureId","computeSignatureId","output","code","boc","abi","stateInit","payload","executorParams","messageHeader","requireOptionalRawFunctionCall","requireObject","now","nowMs","type","createRawExternalMessage","withoutSignature","createExternalMessageWithoutSignature","unsignedMessage","createExternalMessage","publicKey","disableSignatureCheck","signFake","requireKeystore","signer","getSigner","signature","sign","requireBoolean","body","encodeInternalMessage","sender","bounce","amount","blockchainConfig","networkDescription","_ref7","Promise","all","getBlockchainConfig","getNetworkDescription","account","makeFullAccountBoc","overrideBalance","result","globalId","exitCode","Error","resultVariant","newState","parseFullAccountBoc","decoded","_","_ctx","tvc","workchain","initParams","allowPartial","_ref8","fields","unpackContractFields","structure","abiVersion","salt","internal","requireMethodOrArray","event","events","dataHash","isValid","recipient","local","repackedRecipient","makeSignedMessage","expireAt","handleTransaction","signedMessage","sendMessageLocally","retry","errorMessage","catch","additionalText","getDataHash","then","extendSignature","repackedSender","getAccount","prepareMessage","AccountsStorageContext","console","error","context","_ref9","getSignatureId","object","key","property","String","Array","isArray","predicate","requireLastTransactionId","defaultAccount","fetchPublicKey","contractType","NekotonRpcError","Number","isInteger","serialize","serialized","stack","stringifyReplacer"],"sources":["/home/king/Desktop/venom-connect-main/examples/react/node_modules/everscale-standalone-client/client/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EverscaleStandaloneClient = exports.SUPPORTED_PERMISSIONS = exports.VERSION = exports.Clock = exports.SimpleKeystore = exports.checkConnection = exports.ConnectionError = exports.NETWORK_PRESETS = void 0;\nconst fast_safe_stringify_1 = __importDefault(require(\"fast-safe-stringify\"));\nconst core_1 = __importDefault(require(\"../core\"));\nconst utils_1 = require(\"./utils\");\nconst ConnectionController_1 = require(\"./ConnectionController\");\nconst SubscriptionController_1 = require(\"./SubscriptionController\");\nconst AccountsStorage_1 = require(\"./AccountsStorage\");\nvar ConnectionController_2 = require(\"./ConnectionController\");\nObject.defineProperty(exports, \"NETWORK_PRESETS\", { enumerable: true, get: function () { return ConnectionController_2.NETWORK_PRESETS; } });\nvar ConnectionController_3 = require(\"./ConnectionController\");\nObject.defineProperty(exports, \"ConnectionError\", { enumerable: true, get: function () { return ConnectionController_3.ConnectionError; } });\nObject.defineProperty(exports, \"checkConnection\", { enumerable: true, get: function () { return ConnectionController_3.checkConnection; } });\n__exportStar(require(\"./AccountsStorage\"), exports);\nvar keystore_1 = require(\"./keystore\");\nObject.defineProperty(exports, \"SimpleKeystore\", { enumerable: true, get: function () { return keystore_1.SimpleKeystore; } });\nvar clock_1 = require(\"./clock\");\nObject.defineProperty(exports, \"Clock\", { enumerable: true, get: function () { return clock_1.Clock; } });\nconst { ensureNekotonLoaded, nekoton } = core_1.default;\nfunction validateMessageProperties(message) {\n    const m = message || {};\n    return {\n        retryCount: m.retryCount != null ? Math.max(1, ~~m.retryCount) : 5,\n        timeout: m.timeout != null ? Math.max(1, ~~m.timeout) : 60,\n        timeoutGrowFactor: m.timeoutGrowFactor || 1.2,\n        retryTransfers: true,\n    };\n}\n/**\n * @category Client\n */\nexports.VERSION = '0.2.25';\n/**\n * @category Client\n */\nexports.SUPPORTED_PERMISSIONS = ['basic', 'accountInteraction'];\n/**\n * @category Client\n */\nclass EverscaleStandaloneClient extends utils_1.SafeEventEmitter {\n    static async create(params = {}) {\n        await ensureNekotonLoaded(params.initInput);\n        // NOTE: capture client inside notify using wrapper object\n        const notificationContext = {};\n        const notify = (method, params) => {\n            var _a;\n            (_a = notificationContext.client) === null || _a === void 0 ? void 0 : _a.emit(method, params);\n        };\n        const clock = new core_1.default.nekoton.ClockWithOffset();\n        if (params.clock != null) {\n            params.clock['impls'].push(clock);\n            clock.updateOffset(params.clock.offset);\n        }\n        try {\n            const connectionController = params.connection != null ? await (0, ConnectionController_1.createConnectionController)(clock, params.connection) : undefined;\n            const subscriptionController = connectionController != null ? new SubscriptionController_1.SubscriptionController(connectionController, notify) : undefined;\n            const client = new EverscaleStandaloneClient({\n                permissions: {},\n                connectionController,\n                subscriptionController,\n                properties: {\n                    message: validateMessageProperties(params.message),\n                },\n                keystore: params.keystore,\n                accountsStorage: params.accountsStorage,\n                clock,\n                notify,\n            });\n            // NOTE: WeakRef is not working here, so hope it will be garbage collected\n            notificationContext.client = client;\n            return client;\n        }\n        catch (e) {\n            if (params.clock != null) {\n                params.clock['impls'].pop();\n            }\n            clock.free();\n            throw e;\n        }\n    }\n    static setDebugLogger(logger) {\n        core_1.default.debugLog = logger;\n    }\n    constructor(ctx) {\n        super();\n        this._handlers = {\n            requestPermissions,\n            changeAccount,\n            disconnect,\n            subscribe,\n            unsubscribe,\n            unsubscribeAll,\n            getProviderState,\n            getFullContractState,\n            getAccountsByCodeHash,\n            getTransactions,\n            getTransaction,\n            findTransaction,\n            runLocal,\n            executeLocal,\n            getExpectedAddress,\n            getContractFields,\n            unpackInitData,\n            getBocHash,\n            packIntoCell,\n            unpackFromCell,\n            extractPublicKey,\n            codeToTvc,\n            mergeTvc,\n            splitTvc,\n            setCodeSalt,\n            getCodeSalt,\n            encodeInternalInput,\n            decodeInput,\n            decodeOutput,\n            decodeEvent,\n            decodeTransaction,\n            decodeTransactionEvents,\n            verifySignature,\n            sendUnsignedExternalMessage,\n            // addAsset, // not supported\n            signData,\n            signDataRaw,\n            // encryptData, // not supported\n            // decryptData, // not supported\n            // estimateFees, // not supported\n            sendMessage,\n            sendMessageDelayed,\n            sendExternalMessage,\n            sendExternalMessageDelayed,\n        };\n        this._context = ctx;\n    }\n    request(req) {\n        const handler = this._handlers[req.method];\n        if (handler == null) {\n            throw invalidRequest(req, `Method '${req.method}' is not supported by standalone provider`);\n        }\n        return handler(this._context, req);\n    }\n    addListener(eventName, listener) {\n        return super.addListener(eventName, listener);\n    }\n    removeListener(eventName, listener) {\n        return super.removeListener(eventName, listener);\n    }\n    on(eventName, listener) {\n        return super.on(eventName, listener);\n    }\n    once(eventName, listener) {\n        return super.once(eventName, listener);\n    }\n    prependListener(eventName, listener) {\n        return super.prependListener(eventName, listener);\n    }\n    prependOnceListener(eventName, listener) {\n        return super.prependOnceListener(eventName, listener);\n    }\n}\nexports.EverscaleStandaloneClient = EverscaleStandaloneClient;\nconst requestPermissions = async (ctx, req) => {\n    requireParams(req);\n    const { permissions } = req.params;\n    requireArray(req, req.params, 'permissions');\n    const newPermissions = { ...ctx.permissions };\n    for (const permission of permissions) {\n        if (permission === 'basic' || permission === 'tonClient') {\n            newPermissions.basic = true;\n        }\n        else if (permission === 'accountInteraction') {\n            if (newPermissions.accountInteraction != null) {\n                continue;\n            }\n            newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);\n        }\n        else {\n            throw invalidRequest(req, `Permission '${permission}' is not supported by standalone provider`);\n        }\n    }\n    ctx.permissions = newPermissions;\n    // NOTE: be sure to return object copy to prevent adding new permissions\n    const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));\n    ctx.notify('permissionsChanged', {\n        permissions: permissionsCopy,\n    });\n    return permissionsCopy;\n};\nconst changeAccount = async (ctx, req) => {\n    requireAccountsStorage(req, ctx);\n    const newPermissions = { ...ctx.permissions };\n    newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);\n    ctx.permissions = newPermissions;\n    // NOTE: be sure to return object copy to prevent adding new permissions\n    const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));\n    ctx.notify('permissionsChanged', {\n        permissions: permissionsCopy,\n    });\n    return permissionsCopy;\n};\nconst disconnect = async (ctx, _req) => {\n    var _a;\n    ctx.permissions = {};\n    await ((_a = ctx.subscriptionController) === null || _a === void 0 ? void 0 : _a.unsubscribeFromAllContracts());\n    ctx.notify('permissionsChanged', { permissions: {} });\n    return undefined;\n};\nconst subscribe = async (ctx, req) => {\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { address, subscriptions } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptionalObject(req, req.params, 'subscriptions');\n    let repackedAddress;\n    try {\n        repackedAddress = nekoton.repackAddress(address);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    try {\n        return await ctx.subscriptionController.subscribeToContract(repackedAddress, subscriptions);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst unsubscribe = async (ctx, req) => {\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { address } = req.params;\n    requireString(req, req.params, 'address');\n    let repackedAddress;\n    try {\n        repackedAddress = nekoton.repackAddress(address);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    await ctx.subscriptionController.unsubscribeFromContract(repackedAddress);\n    return undefined;\n};\nconst unsubscribeAll = async (ctx, _req) => {\n    var _a;\n    await ((_a = ctx.subscriptionController) === null || _a === void 0 ? void 0 : _a.unsubscribeFromAllContracts());\n    return undefined;\n};\nconst getProviderState = async (ctx, _req) => {\n    var _a, _b;\n    const transport = (_a = ctx.connectionController) === null || _a === void 0 ? void 0 : _a.initializedTransport;\n    const version = exports.VERSION;\n    return {\n        version,\n        numericVersion: (0, utils_1.convertVersionToInt32)(version),\n        networkId: transport != null ? transport.id : 0,\n        selectedConnection: transport != null ? transport.group : '',\n        supportedPermissions: [...exports.SUPPORTED_PERMISSIONS],\n        permissions: JSON.parse(JSON.stringify(ctx.permissions)),\n        subscriptions: ((_b = ctx.subscriptionController) === null || _b === void 0 ? void 0 : _b.subscriptionStates) || {},\n    };\n};\nconst getFullContractState = async (ctx, req) => {\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { address } = req.params;\n    requireString(req, req.params, 'address');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(async ({ data: { transport } }) => ({\n            state: await transport.getFullContractState(address),\n        }));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getAccountsByCodeHash = async (ctx, req) => {\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { codeHash, limit, continuation } = req.params;\n    requireString(req, req.params, 'codeHash');\n    requireOptionalNumber(req, req.params, 'limit');\n    requireOptionalString(req, req.params, 'continuation');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(({ data: { transport } }) => transport.getAccountsByCodeHash(codeHash, limit || 50, continuation));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getTransactions = async (ctx, req) => {\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { address, continuation, limit } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptional(req, req.params, 'continuation', requireTransactionId);\n    requireOptionalNumber(req, req.params, 'limit');\n    const { connectionController } = ctx;\n    try {\n        return connectionController.use(({ data: { transport } }) => transport.getTransactions(address, continuation === null || continuation === void 0 ? void 0 : continuation.lt, limit || 50));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getTransaction = async (ctx, req) => {\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { hash } = req.params;\n    requireString(req, req.params, 'hash');\n    const { connectionController } = ctx;\n    try {\n        return {\n            transaction: await connectionController.use(({ data: { transport } }) => transport.getTransaction(hash)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst findTransaction = async (ctx, req) => {\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { inMessageHash } = req.params;\n    requireOptional(req, req.params, 'inMessageHash', requireString);\n    const { connectionController } = ctx;\n    // TODO: add more filters\n    if (inMessageHash == null) {\n        return {\n            transaction: undefined,\n        };\n    }\n    try {\n        return {\n            transaction: await connectionController.use(({ data: { transport } }) => transport.getDstTransaction(inMessageHash)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst runLocal = async (ctx, req) => {\n    requireParams(req);\n    const { address, cachedState, responsible, functionCall, withSignatureId } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptional(req, req.params, 'cachedState', requireContractState);\n    requireOptionalBoolean(req, req.params, 'responsible');\n    requireFunctionCall(req, req.params, 'functionCall');\n    requireOptionalSignatureId(req, req.params, 'withSignatureId');\n    let contractState = cachedState;\n    if (contractState == null) {\n        requireConnection(req, ctx);\n        contractState = await ctx.connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(address));\n    }\n    if (contractState == null) {\n        throw invalidRequest(req, 'Account not found');\n    }\n    if (!contractState.isDeployed || contractState.lastTransactionId == null) {\n        throw invalidRequest(req, 'Account is not deployed');\n    }\n    const signatureId = await computeSignatureId(req, ctx, withSignatureId);\n    try {\n        const { output, code } = nekoton.runLocal(ctx.clock, contractState.boc, functionCall.abi, functionCall.method, functionCall.params, responsible || false, signatureId);\n        return { output, code };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst executeLocal = async (ctx, req) => {\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { address, cachedState, stateInit, payload, executorParams, messageHeader } = req.params;\n    requireString(req, req.params, 'address');\n    requireOptional(req, req.params, 'cachedState', requireContractState);\n    requireOptionalString(req, req.params, 'stateInit');\n    requireOptionalRawFunctionCall(req, req.params, 'payload');\n    requireOptionalObject(req, req.params, 'executorParams');\n    requireObject(req, req.params, 'messageHeader');\n    const { clock, connectionController } = ctx;\n    let repackedAddress;\n    try {\n        repackedAddress = nekoton.repackAddress(address);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const now = ~~(clock.nowMs / 1000);\n    const timeout = 60;\n    let message;\n    if (messageHeader.type === 'external') {\n        if (payload == null || typeof payload === 'string') {\n            message = nekoton.createRawExternalMessage(repackedAddress, stateInit, payload, now + timeout).boc;\n        }\n        else if (messageHeader.withoutSignature === true) {\n            message = nekoton.createExternalMessageWithoutSignature(clock, repackedAddress, payload.abi, payload.method, stateInit, payload.params, timeout).boc;\n        }\n        else {\n            let unsignedMessage = nekoton.createExternalMessage(clock, repackedAddress, payload.abi, payload.method, stateInit, payload.params, messageHeader.publicKey, timeout);\n            try {\n                if ((executorParams === null || executorParams === void 0 ? void 0 : executorParams.disableSignatureCheck) === true) {\n                    message = unsignedMessage.signFake().boc;\n                }\n                else {\n                    requireKeystore(req, ctx);\n                    const signatureId = await computeSignatureId(req, ctx);\n                    const { keystore } = ctx;\n                    const signer = await keystore.getSigner(messageHeader.publicKey);\n                    if (signer == null) {\n                        throw 'Signer not found for public key';\n                    }\n                    const signature = await signer.sign(unsignedMessage.hash, signatureId);\n                    message = unsignedMessage.sign(signature).boc;\n                }\n            }\n            catch (e) {\n                throw invalidRequest(req, e.toString());\n            }\n            finally {\n                unsignedMessage.free();\n            }\n        }\n    }\n    else if (messageHeader.type === 'internal') {\n        requireString(req, messageHeader, 'sender');\n        requireString(req, messageHeader, 'amount');\n        requireBoolean(req, messageHeader, 'bounce');\n        requireOptionalBoolean(req, messageHeader, 'bounced');\n        const body = payload == null\n            ? undefined\n            : typeof payload === 'string'\n                ? payload\n                : nekoton.encodeInternalInput(payload.abi, payload.method, payload.params);\n        message = nekoton.encodeInternalMessage(messageHeader.sender, repackedAddress, messageHeader.bounce, stateInit, body, messageHeader.amount);\n    }\n    else {\n        throw invalidRequest(req, 'Unknown message type');\n    }\n    try {\n        const [contractState, blockchainConfig, networkDescription] = await connectionController.use(({ data: { transport } }) => Promise.all([\n            cachedState == null ? transport.getFullContractState(repackedAddress) : cachedState,\n            transport.getBlockchainConfig(),\n            transport.getNetworkDescription(),\n        ]));\n        const account = nekoton.makeFullAccountBoc(contractState === null || contractState === void 0 ? void 0 : contractState.boc);\n        const overrideBalance = executorParams === null || executorParams === void 0 ? void 0 : executorParams.overrideBalance;\n        const result = nekoton.executeLocal(blockchainConfig, account, message, now, (executorParams === null || executorParams === void 0 ? void 0 : executorParams.disableSignatureCheck) === true, overrideBalance != null ? overrideBalance.toString() : undefined, networkDescription.globalId);\n        if (result.exitCode != null) {\n            throw new Error(`Contract did not accept the message. Exit code: ${result.exitCode}`);\n        }\n        const resultVariant = result;\n        const transaction = resultVariant.transaction;\n        const newState = nekoton.parseFullAccountBoc(resultVariant.account);\n        let output;\n        try {\n            if (typeof payload === 'object' && typeof payload != null) {\n                const decoded = nekoton.decodeTransaction(resultVariant.transaction, payload.abi, payload.method);\n                output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n            }\n        }\n        catch (_) {\n            /* do nothing */\n        }\n        return {\n            transaction,\n            newState,\n            output,\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getExpectedAddress = async (_ctx, req) => {\n    requireParams(req);\n    const { tvc, abi, workchain, publicKey, initParams } = req.params;\n    requireString(req, req.params, 'tvc');\n    requireString(req, req.params, 'abi');\n    requireOptionalNumber(req, req.params, 'workchain');\n    requireOptionalString(req, req.params, 'publicKey');\n    try {\n        return nekoton.getExpectedAddress(tvc, abi, workchain || 0, publicKey, initParams);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getContractFields = async (ctx, req) => {\n    requireParams(req);\n    const { address, abi, cachedState, allowPartial } = req.params;\n    requireString(req, req.params, 'address');\n    requireString(req, req.params, 'abi');\n    requireOptional(req, req.params, 'cachedState', requireContractState);\n    requireBoolean(req, req.params, 'allowPartial');\n    let repackedAddress;\n    try {\n        repackedAddress = nekoton.repackAddress(address);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    let contractState = cachedState;\n    if (contractState == null) {\n        requireConnection(req, ctx);\n        contractState = await ctx.connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(repackedAddress));\n    }\n    if (contractState == null) {\n        return {\n            fields: undefined,\n            state: undefined,\n        };\n    }\n    if (!contractState.isDeployed || contractState.lastTransactionId == null) {\n        return {\n            fields: undefined,\n            state: contractState,\n        };\n    }\n    try {\n        const fields = nekoton.unpackContractFields(abi, contractState.boc, allowPartial);\n        return {\n            fields,\n            state: contractState,\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst unpackInitData = async (_ctx, req) => {\n    requireParams(req);\n    const { abi, data } = req.params;\n    requireString(req, req.params, 'abi');\n    requireString(req, req.params, 'data');\n    try {\n        const { publicKey, data: initParams } = nekoton.unpackInitData(abi, data);\n        return { publicKey, initParams };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getBocHash = async (_ctx, req) => {\n    requireParams(req);\n    const { boc } = req.params;\n    requireString(req, req.params, 'boc');\n    try {\n        return { hash: nekoton.getBocHash(boc) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst packIntoCell = async (_ctx, req) => {\n    requireParams(req);\n    const { structure, data, abiVersion } = req.params;\n    requireArray(req, req.params, 'structure');\n    requireOptional(req, req.params, 'abiVersion', requireString);\n    try {\n        return nekoton.packIntoCell(structure, data, abiVersion);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst unpackFromCell = async (_ctx, req) => {\n    requireParams(req);\n    const { structure, boc, allowPartial, abiVersion } = req.params;\n    requireArray(req, req.params, 'structure');\n    requireString(req, req.params, 'boc');\n    requireBoolean(req, req.params, 'allowPartial');\n    requireOptional(req, req.params, 'abiVersion', requireString);\n    try {\n        return { data: nekoton.unpackFromCell(structure, boc, allowPartial, abiVersion) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst extractPublicKey = async (_ctx, req) => {\n    requireParams(req);\n    const { boc } = req.params;\n    requireString(req, req.params, 'boc');\n    try {\n        return { publicKey: nekoton.extractPublicKey(boc) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst codeToTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { code } = req.params;\n    requireString(req, req.params, 'code');\n    try {\n        const { boc, hash } = nekoton.codeToTvc(code);\n        return { tvc: boc, hash };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst mergeTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { code, data } = req.params;\n    requireString(req, req.params, 'code');\n    requireString(req, req.params, 'data');\n    try {\n        const { boc, hash } = nekoton.mergeTvc(code, data);\n        return { tvc: boc, hash };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst splitTvc = async (_ctx, req) => {\n    requireParams(req);\n    const { tvc } = req.params;\n    requireString(req, req.params, 'tvc');\n    try {\n        return nekoton.splitTvc(tvc);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst setCodeSalt = async (_ctx, req) => {\n    requireParams(req);\n    const { code, salt } = req.params;\n    requireString(req, req.params, 'code');\n    requireString(req, req.params, 'salt');\n    try {\n        const { boc, hash } = nekoton.setCodeSalt(code, salt);\n        return { code: boc, hash };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst getCodeSalt = async (_ctx, req) => {\n    requireParams(req);\n    const { code } = req.params;\n    requireString(req, req.params, 'code');\n    try {\n        return { salt: nekoton.getCodeSalt(code) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst encodeInternalInput = async (_ctx, req) => {\n    requireParams(req);\n    requireFunctionCall(req, req, 'params');\n    const { abi, method, params } = req.params;\n    try {\n        return { boc: nekoton.encodeInternalInput(abi, method, params) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeInput = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, method, internal } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    requireBoolean(req, req.params, 'internal');\n    try {\n        return nekoton.decodeInput(body, abi, method, internal) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeOutput = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, method } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    try {\n        return nekoton.decodeOutput(body, abi, method) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeEvent = async (_ctx, req) => {\n    requireParams(req);\n    const { body, abi, event } = req.params;\n    requireString(req, req.params, 'body');\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'event');\n    try {\n        return nekoton.decodeEvent(body, abi, event) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeTransaction = async (_ctx, req) => {\n    requireParams(req);\n    const { transaction, abi, method } = req.params;\n    requireString(req, req.params, 'abi');\n    requireMethodOrArray(req, req.params, 'method');\n    try {\n        return nekoton.decodeTransaction(transaction, abi, method) || null;\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst decodeTransactionEvents = async (_ctx, req) => {\n    requireParams(req);\n    const { transaction, abi } = req.params;\n    requireString(req, req.params, 'abi');\n    try {\n        return { events: nekoton.decodeTransactionEvents(transaction, abi) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst verifySignature = async (ctx, req) => {\n    requireParams(req);\n    const { publicKey, dataHash, signature, withSignatureId } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'dataHash');\n    requireString(req, req.params, 'signature');\n    requireOptionalSignatureId(req, req.params, 'withSignatureId');\n    const signatureId = await computeSignatureId(req, ctx, withSignatureId);\n    try {\n        return { isValid: nekoton.verifySignature(publicKey, dataHash, signature, signatureId) };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst sendUnsignedExternalMessage = async (ctx, req) => {\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { recipient, stateInit, payload, local, executorParams } = req.params;\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireOptionalRawFunctionCall(req, req.params, 'payload');\n    requireOptionalBoolean(req, req.params, 'local');\n    requireOptionalObject(req, req.params, 'executorParams');\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, properties } = ctx;\n    const makeSignedMessage = (timeout) => {\n        try {\n            if (typeof payload === 'string' || payload == null) {\n                const expireAt = ~~(clock.nowMs / 1000) + timeout;\n                return nekoton.createRawExternalMessage(repackedRecipient, stateInit, payload, ~~expireAt);\n            }\n            else {\n                return nekoton.createExternalMessageWithoutSignature(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, ~~timeout);\n            }\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n    };\n    const handleTransaction = (transaction) => {\n        let output;\n        try {\n            if (typeof payload === 'object' && typeof payload != null) {\n                const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);\n                output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n            }\n        }\n        catch (_) {\n            /* do nothing */\n        }\n        return { transaction, output };\n    };\n    // Force local execution\n    if (local === true) {\n        const signedMessage = makeSignedMessage(60);\n        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage, executorParams);\n        return handleTransaction(transaction);\n    }\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    for (let retry = 0; retry < properties.message.retryCount; ++retry) {\n        const signedMessage = makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return handleTransaction(transaction);\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage).catch(e => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst signData = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, data, withSignatureId } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'data');\n    requireOptionalSignatureId(req, req.params, 'withSignatureId');\n    const signatureId = await computeSignatureId(req, ctx, withSignatureId);\n    const { keystore } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    try {\n        const dataHash = nekoton.getDataHash(data);\n        return {\n            dataHash,\n            ...(await signer.sign(dataHash, signatureId).then(nekoton.extendSignature)),\n        };\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst signDataRaw = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    const { publicKey, data, withSignatureId } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'data');\n    requireOptionalSignatureId(req, req.params, 'withSignatureId');\n    const signatureId = await computeSignatureId(req, ctx, withSignatureId);\n    const { keystore } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    try {\n        return await signer.sign(data, signatureId).then(nekoton.extendSignature);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n};\nconst sendMessage = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireAccountsStorage(req, ctx);\n    requireConnection(req, ctx);\n    requireParams(req);\n    const { sender, recipient, amount, bounce, payload, stateInit } = req.params;\n    requireString(req, req.params, 'sender');\n    requireString(req, req.params, 'recipient');\n    requireString(req, req.params, 'amount');\n    requireBoolean(req, req.params, 'bounce');\n    requireOptional(req, req.params, 'payload', requireFunctionCall);\n    requireOptionalString(req, req.params, 'stateInit');\n    const signatureId = await computeSignatureId(req, ctx);\n    const { clock, properties, subscriptionController, connectionController, keystore, accountsStorage } = ctx;\n    let repackedSender;\n    let repackedRecipient;\n    let account;\n    try {\n        repackedSender = nekoton.repackAddress(sender);\n        repackedRecipient = nekoton.repackAddress(recipient);\n        account = await accountsStorage.getAccount(repackedSender).then(account => {\n            if (account != null) {\n                return account;\n            }\n            else {\n                throw new Error('Sender not found');\n            }\n        });\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const makeSignedMessage = async (timeout) => {\n        try {\n            return account.prepareMessage({\n                recipient: repackedRecipient,\n                amount,\n                bounce,\n                payload,\n                stateInit,\n                timeout: ~~timeout,\n                signatureId,\n            }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n    };\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    // Set `retryCount` if not explicitly disabled\n    const retryCount = properties.message.retryTransfers !== false ? properties.message.retryCount : 1;\n    for (let retry = 0; retry < retryCount; ++retry) {\n        const signedMessage = await makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedSender, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return { transaction };\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = await makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedSender, signedMessage).catch(e => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst sendMessageDelayed = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireAccountsStorage(req, ctx);\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { sender, recipient, amount, bounce, payload, stateInit } = req.params;\n    requireString(req, req.params, 'sender');\n    requireString(req, req.params, 'recipient');\n    requireString(req, req.params, 'amount');\n    requireBoolean(req, req.params, 'bounce');\n    requireOptional(req, req.params, 'payload', requireFunctionCall);\n    requireOptionalString(req, req.params, 'stateInit');\n    const signatureId = await computeSignatureId(req, ctx);\n    const { clock, subscriptionController, connectionController, keystore, accountsStorage, notify } = ctx;\n    let repackedSender;\n    let repackedRecipient;\n    try {\n        repackedSender = nekoton.repackAddress(sender);\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    let signedMessage;\n    try {\n        const account = await accountsStorage.getAccount(repackedSender);\n        if (account == null) {\n            throw new Error('Sender not found');\n        }\n        signedMessage = await account.prepareMessage({\n            recipient: repackedRecipient,\n            amount,\n            bounce,\n            payload,\n            stateInit,\n            timeout: 60,\n            signatureId,\n        }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    subscriptionController\n        .sendMessage(repackedSender, signedMessage)\n        .then(transaction => {\n        notify('messageStatusUpdated', {\n            address: repackedSender,\n            hash: signedMessage.hash,\n            transaction,\n        });\n    })\n        .catch(console.error);\n    return {\n        message: {\n            account: repackedSender,\n            hash: signedMessage.hash,\n            expireAt: signedMessage.expireAt,\n        },\n    };\n};\nconst sendExternalMessage = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { publicKey, recipient, stateInit, payload, local, executorParams } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireFunctionCall(req, req.params, 'payload');\n    requireOptionalBoolean(req, req.params, 'local');\n    requireOptionalObject(req, req.params, 'executorParams');\n    const signatureId = await computeSignatureId(req, ctx);\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, keystore, properties } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    const makeSignedMessage = async (timeout) => {\n        let unsignedMessage;\n        try {\n            unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, ~~timeout);\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n        try {\n            const signature = await signer.sign(unsignedMessage.hash, signatureId);\n            return unsignedMessage.sign(signature);\n        }\n        catch (e) {\n            throw invalidRequest(req, e.toString());\n        }\n        finally {\n            unsignedMessage.free();\n        }\n    };\n    const handleTransaction = (transaction) => {\n        let output;\n        try {\n            const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);\n            output = decoded === null || decoded === void 0 ? void 0 : decoded.output;\n        }\n        catch (_) {\n            /* do nothing */\n        }\n        return { transaction, output };\n    };\n    // Force local execution\n    if (local === true) {\n        const signedMessage = await makeSignedMessage(60);\n        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage, executorParams);\n        return handleTransaction(transaction);\n    }\n    // Send and wait with several retries\n    let timeout = properties.message.timeout;\n    for (let retry = 0; retry < properties.message.retryCount; ++retry) {\n        const signedMessage = await makeSignedMessage(timeout);\n        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);\n        if (transaction == null) {\n            timeout *= properties.message.timeoutGrowFactor;\n            continue;\n        }\n        return handleTransaction(transaction);\n    }\n    // Execute locally\n    const errorMessage = 'Message expired';\n    const signedMessage = await makeSignedMessage(60);\n    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage).catch(e => {\n        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);\n    });\n    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';\n    throw invalidRequest(req, `${errorMessage}${additionalText}`);\n};\nconst sendExternalMessageDelayed = async (ctx, req) => {\n    requireKeystore(req, ctx);\n    requireParams(req);\n    requireConnection(req, ctx);\n    const { publicKey, recipient, stateInit, payload } = req.params;\n    requireString(req, req.params, 'publicKey');\n    requireString(req, req.params, 'recipient');\n    requireOptionalString(req, req.params, 'stateInit');\n    requireFunctionCall(req, req.params, 'payload');\n    const signatureId = await computeSignatureId(req, ctx);\n    let repackedRecipient;\n    try {\n        repackedRecipient = nekoton.repackAddress(recipient);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    const { clock, subscriptionController, keystore, properties, notify } = ctx;\n    const signer = await keystore.getSigner(publicKey);\n    if (signer == null) {\n        throw invalidRequest(req, 'Signer not found for public key');\n    }\n    let unsignedMessage;\n    try {\n        unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, ~~properties.message.timeout);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    let signedMessage;\n    try {\n        const signature = await signer.sign(unsignedMessage.hash, signatureId);\n        signedMessage = unsignedMessage.sign(signature);\n    }\n    catch (e) {\n        throw invalidRequest(req, e.toString());\n    }\n    finally {\n        unsignedMessage.free();\n    }\n    subscriptionController\n        .sendMessage(repackedRecipient, signedMessage)\n        .then(transaction => {\n        notify('messageStatusUpdated', {\n            address: repackedRecipient,\n            hash: signedMessage.hash,\n            transaction,\n        });\n    })\n        .catch(console.error);\n    return {\n        message: {\n            account: repackedRecipient,\n            hash: signedMessage.hash,\n            expireAt: signedMessage.expireAt,\n        },\n    };\n};\nfunction requireKeystore(req, context) {\n    if (context.keystore == null) {\n        throw invalidRequest(req, 'Keystore not found');\n    }\n}\nfunction requireAccountsStorage(req, context) {\n    if (context.accountsStorage == null) {\n        throw invalidRequest(req, 'AccountsStorage not found');\n    }\n}\nfunction requireConnection(req, context) {\n    if (context.connectionController == null || context.subscriptionController == null) {\n        throw invalidRequest(req, 'Connection was not initialized');\n    }\n}\nasync function computeSignatureId(req, ctx, withSignatureId) {\n    if (withSignatureId === false) {\n        return undefined;\n    }\n    else if (typeof withSignatureId === 'number') {\n        return withSignatureId;\n    }\n    else if (ctx.connectionController == null) {\n        return undefined;\n    }\n    return ctx.connectionController\n        .use(async ({ data: { transport } }) => transport.getSignatureId())\n        .catch(_ => {\n        throw invalidRequest(req, 'Failed to fetch signature id');\n    });\n}\nfunction requireParams(req) {\n    if (req.params == null || typeof req.params !== 'object') {\n        throw invalidRequest(req, 'required params object');\n    }\n}\nfunction requireObject(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'object') {\n        throw invalidRequest(req, `'${String(key)}' must be an object`);\n    }\n}\nfunction requireOptionalObject(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'object') {\n        throw invalidRequest(req, `'${String(key)}' must be an object if specified`);\n    }\n}\nfunction requireBoolean(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'boolean') {\n        throw invalidRequest(req, `'${String(key)}' must be a boolean`);\n    }\n}\nfunction requireOptionalBoolean(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'boolean') {\n        throw invalidRequest(req, `'${String(key)}' must be a boolean if specified`);\n    }\n}\nfunction requireString(req, object, key) {\n    const property = object[key];\n    if (typeof property !== 'string' || property.length === 0) {\n        throw invalidRequest(req, `'${String(key)}' must be non-empty string`);\n    }\n}\nfunction requireOptionalString(req, object, key) {\n    const property = object[key];\n    if (property != null && (typeof property !== 'string' || property.length === 0)) {\n        throw invalidRequest(req, `'${String(key)}' must be a non-empty string if provided`);\n    }\n}\nfunction requireOptionalNumber(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'number') {\n        throw invalidRequest(req, `'${String(key)}' must be a number if provider`);\n    }\n}\nfunction requireArray(req, object, key) {\n    const property = object[key];\n    if (!Array.isArray(property)) {\n        throw invalidRequest(req, `'${String(key)}' must be an array`);\n    }\n}\nfunction requireOptional(req, object, key, predicate) {\n    const property = object[key];\n    if (property != null) {\n        predicate(req, object, key);\n    }\n}\nfunction requireOptionalSignatureId(req, object, key) {\n    const property = object[key];\n    if (property != null) {\n        if (typeof property !== 'boolean' && typeof property !== 'number') {\n            throw invalidRequest(req, `'${String(key)}' must be an optional boolean or number`);\n        }\n    }\n}\nfunction requireTransactionId(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'lt');\n    requireString(req, property, 'hash');\n}\nfunction requireLastTransactionId(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireBoolean(req, property, 'isExact');\n    requireString(req, property, 'lt');\n    requireOptionalString(req, property, 'hash');\n}\nfunction requireContractState(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'balance');\n    requireOptional(req, property, 'lastTransactionId', requireLastTransactionId);\n    requireBoolean(req, property, 'isDeployed');\n}\nfunction requireFunctionCall(req, object, key) {\n    requireObject(req, object, key);\n    const property = object[key];\n    requireString(req, property, 'abi');\n    requireString(req, property, 'method');\n    requireObject(req, property, 'params');\n}\nfunction requireOptionalRawFunctionCall(req, object, key) {\n    const property = object[key];\n    if (typeof property === 'string' || property == null) {\n        return;\n    }\n    else if (typeof property === 'object') {\n        requireString(req, property, 'abi');\n        requireString(req, property, 'method');\n        requireObject(req, property, 'params');\n    }\n    else {\n        throw invalidRequest(req, `'${String(key)}' must be a function all or optional string`);\n    }\n}\nfunction requireMethodOrArray(req, object, key) {\n    const property = object[key];\n    if (property != null && typeof property !== 'string' && !Array.isArray(property)) {\n        throw invalidRequest(req, `'${String(key)}' must be a method name or an array of possible names`);\n    }\n}\nasync function makeAccountInteractionPermission(req, ctx) {\n    requireAccountsStorage(req, ctx);\n    requireConnection(req, ctx);\n    const defaultAccount = ctx.accountsStorage.defaultAccount;\n    if (defaultAccount == null) {\n        throw invalidRequest(req, 'Default account not set in accounts storage');\n    }\n    const account = await ctx.accountsStorage.getAccount(defaultAccount);\n    if (account == null) {\n        throw invalidRequest(req, 'Default account not found');\n    }\n    const publicKey = await account.fetchPublicKey(new AccountsStorage_1.AccountsStorageContext(ctx.clock, ctx.connectionController, nekoton));\n    return {\n        address: account.address.toString(),\n        publicKey,\n        contractType: 'unknown',\n    };\n}\nconst invalidRequest = (req, message, data) => new NekotonRpcError(2, `${req.method}: ${message}`, data);\nclass NekotonRpcError extends Error {\n    constructor(code, message, data) {\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer');\n        }\n        if (!message || typeof message !== 'string') {\n            throw new Error('\"message\" must be a nonempty string');\n        }\n        super(message);\n        this.code = code;\n        this.data = data;\n    }\n    serialize() {\n        const serialized = {\n            code: this.code,\n            message: this.message,\n        };\n        if (this.data !== undefined) {\n            serialized.data = this.data;\n        }\n        if (this.stack) {\n            serialized.stack = this.stack;\n        }\n        return serialized;\n    }\n    toString() {\n        return (0, fast_safe_stringify_1.default)(this.serialize(), stringifyReplacer, 2);\n    }\n}\nconst stringifyReplacer = (_, value) => {\n    if (value === '[Circular]') {\n        return undefined;\n    }\n    return value;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}