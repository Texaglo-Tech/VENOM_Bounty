{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContractSubscription = void 0;\nconst await_semaphore_1 = require(\"@broxus/await-semaphore\");\nconst core_1 = __importDefault(require(\"../../core\"));\nconst {\n  nekoton,\n  debugLog\n} = core_1.default;\nclass ContractSubscription {\n  static async subscribe(connectionController, address, handler) {\n    const {\n      transport: {\n        data: {\n          connection,\n          transport\n        }\n      },\n      release\n    } = await connectionController.acquire();\n    try {\n      const contract = await transport.subscribeToGenericContract(address, handler);\n      if (contract == null) {\n        throw new Error(`Failed to subscribe to contract: ${address}`);\n      }\n      return new ContractSubscription(connection, release, address, contract);\n    } catch (e) {\n      release();\n      throw e;\n    }\n  }\n  constructor(connection, release, address, contract) {\n    this._contractMutex = new await_semaphore_1.Mutex();\n    this._pollingInterval = BACKGROUND_POLLING_INTERVAL;\n    this._isRunning = false;\n    this._skipIteration = false;\n    this._connection = connection;\n    this._address = address;\n    this._contract = contract;\n    this._releaseTransport = release;\n    this._currentPollingMethod = contract.pollingMethod;\n  }\n  setPollingInterval(interval) {\n    this._pollingInterval = interval;\n  }\n  async start() {\n    if (this._releaseTransport == null) {\n      throw new Error('Contract subscription must not be started after being closed');\n    }\n    if (this._loopPromise) {\n      debugLog('ContractSubscription -> awaiting loop promise');\n      await this._loopPromise;\n    }\n    debugLog('ContractSubscription -> loop started');\n    this._loopPromise = (async () => {\n      const isSimple = !(this._connection instanceof nekoton.GqlConnection);\n      this._isRunning = true;\n      let previousPollingMethod = this._currentPollingMethod;\n      while (this._isRunning) {\n        this._skipIteration = false; // always reset this flag\n        const pollingMethodChanged = previousPollingMethod != this._currentPollingMethod;\n        previousPollingMethod = this._currentPollingMethod;\n        if (isSimple || this._currentPollingMethod == 'manual') {\n          this._currentBlockId = undefined;\n          debugLog('ContractSubscription -> manual -> waiting begins');\n          const pollingInterval = this._currentPollingMethod == 'manual' ? this._pollingInterval : INTENSIVE_POLLING_INTERVAL;\n          await new Promise(resolve => {\n            const timerHandle = setTimeout(() => {\n              this._refreshTimer = undefined;\n              resolve();\n            }, pollingInterval);\n            this._refreshTimer = [timerHandle, resolve];\n          });\n          debugLog('ContractSubscription -> manual -> waiting ends');\n          if (this._skipIteration) {\n            continue;\n          }\n          if (!this._isRunning) {\n            break;\n          }\n          debugLog('ContractSubscription -> manual -> refreshing begins');\n          try {\n            this._currentPollingMethod = await this._contractMutex.use(async () => {\n              await this._contract.refresh();\n              return this._contract.pollingMethod;\n            });\n          } catch (e) {\n            console.error(`Error during account refresh (${this._address})`, e);\n          }\n          debugLog('ContractSubscription -> manual -> refreshing ends');\n        } else {\n          // SAFETY: connection is always GqlConnection here due to `isSimple`\n          const connection = this._connection;\n          debugLog('ContractSubscription -> reliable start');\n          if (pollingMethodChanged && this._suggestedBlockId != null) {\n            this._currentBlockId = this._suggestedBlockId;\n          }\n          this._suggestedBlockId = undefined;\n          let nextBlockId;\n          if (this._currentBlockId == null) {\n            console.warn('Starting reliable connection with unknown block');\n            try {\n              const latestBlock = await connection.getLatestBlock(this._address);\n              this._currentBlockId = latestBlock.id;\n              nextBlockId = this._currentBlockId;\n            } catch (e) {\n              console.error(`Failed to get latest block for ${this._address}`, e);\n              continue;\n            }\n          } else {\n            try {\n              nextBlockId = await connection.waitForNextBlock(this._currentBlockId, this._address, NEXT_BLOCK_TIMEOUT);\n            } catch (e) {\n              console.error(`Failed to wait for next block for ${this._address}`);\n              continue; // retry\n            }\n          }\n\n          try {\n            this._currentPollingMethod = await this._contractMutex.use(async () => {\n              await this._contract.handleBlock(nextBlockId);\n              return this._contract.pollingMethod;\n            });\n            this._currentBlockId = nextBlockId;\n          } catch (e) {\n            console.error(`Failed to handle block for ${this._address}`, e);\n          }\n        }\n      }\n      debugLog('ContractSubscription -> loop finished');\n    })();\n  }\n  skipRefreshTimer(pollingMethod) {\n    var _a, _b;\n    if (pollingMethod != null) {\n      this._currentPollingMethod = pollingMethod;\n      this._skipIteration = true;\n    }\n    clearTimeout((_a = this._refreshTimer) === null || _a === void 0 ? void 0 : _a[0]);\n    (_b = this._refreshTimer) === null || _b === void 0 ? void 0 : _b[1]();\n    this._refreshTimer = undefined;\n  }\n  async pause() {\n    if (!this._isRunning) {\n      return;\n    }\n    this._isRunning = false;\n    this.skipRefreshTimer();\n    await this._loopPromise;\n    this._loopPromise = undefined;\n    this._currentPollingMethod = await this._contractMutex.use(async () => {\n      return this._contract.pollingMethod;\n    });\n    this._currentBlockId = undefined;\n    this._suggestedBlockId = undefined;\n  }\n  async stop() {\n    var _a;\n    await this.pause();\n    this._contract.free();\n    (_a = this._releaseTransport) === null || _a === void 0 ? void 0 : _a.call(this);\n    this._releaseTransport = undefined;\n  }\n  async prepareReliablePolling() {\n    try {\n      if (this._connection instanceof nekoton.GqlConnection) {\n        this._suggestedBlockId = (await this._connection.getLatestBlock(this._address)).id;\n      }\n    } catch (e) {\n      throw new Error(`Failed to prepare reliable polling: ${e.toString()}`);\n    }\n  }\n  async use(f) {\n    const release = await this._contractMutex.acquire();\n    return f(this._contract).then(res => {\n      release();\n      return res;\n    }).catch(err => {\n      release();\n      throw err;\n    });\n  }\n}\nexports.ContractSubscription = ContractSubscription;\nconst NEXT_BLOCK_TIMEOUT = 60; // 60s\nconst INTENSIVE_POLLING_INTERVAL = 2000; // 2s\nconst BACKGROUND_POLLING_INTERVAL = 60000;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","ContractSubscription","await_semaphore_1","require","core_1","nekoton","debugLog","default","subscribe","connectionController","address","handler","transport","data","connection","release","acquire","contract","subscribeToGenericContract","Error","e","constructor","_contractMutex","Mutex","_pollingInterval","BACKGROUND_POLLING_INTERVAL","_isRunning","_skipIteration","_connection","_address","_contract","_releaseTransport","_currentPollingMethod","pollingMethod","setPollingInterval","interval","start","_loopPromise","isSimple","GqlConnection","previousPollingMethod","pollingMethodChanged","_currentBlockId","undefined","pollingInterval","INTENSIVE_POLLING_INTERVAL","Promise","resolve","timerHandle","setTimeout","_refreshTimer","use","refresh","console","error","_suggestedBlockId","nextBlockId","warn","latestBlock","getLatestBlock","id","waitForNextBlock","NEXT_BLOCK_TIMEOUT","handleBlock","skipRefreshTimer","_a","_b","clearTimeout","pause","stop","free","call","prepareReliablePolling","toString","f","then","res","catch","err"],"sources":["/home/king/Desktop/venom-connect-main/examples/react/node_modules/everscale-standalone-client/client/SubscriptionController/subscription.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContractSubscription = void 0;\nconst await_semaphore_1 = require(\"@broxus/await-semaphore\");\nconst core_1 = __importDefault(require(\"../../core\"));\nconst { nekoton, debugLog } = core_1.default;\nclass ContractSubscription {\n    static async subscribe(connectionController, address, handler) {\n        const { transport: { data: { connection, transport }, }, release, } = await connectionController.acquire();\n        try {\n            const contract = await transport.subscribeToGenericContract(address, handler);\n            if (contract == null) {\n                throw new Error(`Failed to subscribe to contract: ${address}`);\n            }\n            return new ContractSubscription(connection, release, address, contract);\n        }\n        catch (e) {\n            release();\n            throw e;\n        }\n    }\n    constructor(connection, release, address, contract) {\n        this._contractMutex = new await_semaphore_1.Mutex();\n        this._pollingInterval = BACKGROUND_POLLING_INTERVAL;\n        this._isRunning = false;\n        this._skipIteration = false;\n        this._connection = connection;\n        this._address = address;\n        this._contract = contract;\n        this._releaseTransport = release;\n        this._currentPollingMethod = contract.pollingMethod;\n    }\n    setPollingInterval(interval) {\n        this._pollingInterval = interval;\n    }\n    async start() {\n        if (this._releaseTransport == null) {\n            throw new Error('Contract subscription must not be started after being closed');\n        }\n        if (this._loopPromise) {\n            debugLog('ContractSubscription -> awaiting loop promise');\n            await this._loopPromise;\n        }\n        debugLog('ContractSubscription -> loop started');\n        this._loopPromise = (async () => {\n            const isSimple = !(this._connection instanceof nekoton.GqlConnection);\n            this._isRunning = true;\n            let previousPollingMethod = this._currentPollingMethod;\n            while (this._isRunning) {\n                this._skipIteration = false; // always reset this flag\n                const pollingMethodChanged = previousPollingMethod != this._currentPollingMethod;\n                previousPollingMethod = this._currentPollingMethod;\n                if (isSimple || this._currentPollingMethod == 'manual') {\n                    this._currentBlockId = undefined;\n                    debugLog('ContractSubscription -> manual -> waiting begins');\n                    const pollingInterval = this._currentPollingMethod == 'manual' ? this._pollingInterval : INTENSIVE_POLLING_INTERVAL;\n                    await new Promise(resolve => {\n                        const timerHandle = setTimeout(() => {\n                            this._refreshTimer = undefined;\n                            resolve();\n                        }, pollingInterval);\n                        this._refreshTimer = [timerHandle, resolve];\n                    });\n                    debugLog('ContractSubscription -> manual -> waiting ends');\n                    if (this._skipIteration) {\n                        continue;\n                    }\n                    if (!this._isRunning) {\n                        break;\n                    }\n                    debugLog('ContractSubscription -> manual -> refreshing begins');\n                    try {\n                        this._currentPollingMethod = await this._contractMutex.use(async () => {\n                            await this._contract.refresh();\n                            return this._contract.pollingMethod;\n                        });\n                    }\n                    catch (e) {\n                        console.error(`Error during account refresh (${this._address})`, e);\n                    }\n                    debugLog('ContractSubscription -> manual -> refreshing ends');\n                }\n                else {\n                    // SAFETY: connection is always GqlConnection here due to `isSimple`\n                    const connection = this._connection;\n                    debugLog('ContractSubscription -> reliable start');\n                    if (pollingMethodChanged && this._suggestedBlockId != null) {\n                        this._currentBlockId = this._suggestedBlockId;\n                    }\n                    this._suggestedBlockId = undefined;\n                    let nextBlockId;\n                    if (this._currentBlockId == null) {\n                        console.warn('Starting reliable connection with unknown block');\n                        try {\n                            const latestBlock = await connection.getLatestBlock(this._address);\n                            this._currentBlockId = latestBlock.id;\n                            nextBlockId = this._currentBlockId;\n                        }\n                        catch (e) {\n                            console.error(`Failed to get latest block for ${this._address}`, e);\n                            continue;\n                        }\n                    }\n                    else {\n                        try {\n                            nextBlockId = await connection.waitForNextBlock(this._currentBlockId, this._address, NEXT_BLOCK_TIMEOUT);\n                        }\n                        catch (e) {\n                            console.error(`Failed to wait for next block for ${this._address}`);\n                            continue; // retry\n                        }\n                    }\n                    try {\n                        this._currentPollingMethod = await this._contractMutex.use(async () => {\n                            await this._contract.handleBlock(nextBlockId);\n                            return this._contract.pollingMethod;\n                        });\n                        this._currentBlockId = nextBlockId;\n                    }\n                    catch (e) {\n                        console.error(`Failed to handle block for ${this._address}`, e);\n                    }\n                }\n            }\n            debugLog('ContractSubscription -> loop finished');\n        })();\n    }\n    skipRefreshTimer(pollingMethod) {\n        var _a, _b;\n        if (pollingMethod != null) {\n            this._currentPollingMethod = pollingMethod;\n            this._skipIteration = true;\n        }\n        clearTimeout((_a = this._refreshTimer) === null || _a === void 0 ? void 0 : _a[0]);\n        (_b = this._refreshTimer) === null || _b === void 0 ? void 0 : _b[1]();\n        this._refreshTimer = undefined;\n    }\n    async pause() {\n        if (!this._isRunning) {\n            return;\n        }\n        this._isRunning = false;\n        this.skipRefreshTimer();\n        await this._loopPromise;\n        this._loopPromise = undefined;\n        this._currentPollingMethod = await this._contractMutex.use(async () => {\n            return this._contract.pollingMethod;\n        });\n        this._currentBlockId = undefined;\n        this._suggestedBlockId = undefined;\n    }\n    async stop() {\n        var _a;\n        await this.pause();\n        this._contract.free();\n        (_a = this._releaseTransport) === null || _a === void 0 ? void 0 : _a.call(this);\n        this._releaseTransport = undefined;\n    }\n    async prepareReliablePolling() {\n        try {\n            if (this._connection instanceof nekoton.GqlConnection) {\n                this._suggestedBlockId = (await this._connection.getLatestBlock(this._address)).id;\n            }\n        }\n        catch (e) {\n            throw new Error(`Failed to prepare reliable polling: ${e.toString()}`);\n        }\n    }\n    async use(f) {\n        const release = await this._contractMutex.acquire();\n        return f(this._contract)\n            .then(res => {\n            release();\n            return res;\n        })\n            .catch(err => {\n            release();\n            throw err;\n        });\n    }\n}\nexports.ContractSubscription = ContractSubscription;\nconst NEXT_BLOCK_TIMEOUT = 60; // 60s\nconst INTENSIVE_POLLING_INTERVAL = 2000; // 2s\nconst BACKGROUND_POLLING_INTERVAL = 60000;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}