{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subscriber = void 0;\nconst utils_1 = require(\"./utils\");\nconst models_1 = require(\"./models\");\n/**\n * @category Stream\n */\nclass Subscriber {\n  constructor(provider) {\n    this.provider = provider;\n    this.subscriptions = new Map();\n    this.scanners = new Map();\n    this.unsubscribe = async () => this._unsubscribe();\n  }\n  /**\n   * Returns a stream of new transactions\n   */\n  transactions(address) {\n    return this._addSubscription('transactionsFound', address, false);\n  }\n  /**\n   * Returns a finite stream of child transactions\n   * @param transaction - root transaction\n   */\n  trace(transaction) {\n    const id = (0, utils_1.getUniqueId)();\n    return new StreamImpl((onData, onEnd) => {\n      const scanner = new TraceTransactionsScanner(this.provider, {\n        origin: transaction,\n        onData,\n        onEnd: eof => {\n          this.scanners.delete(id);\n          onEnd(eof);\n        }\n      });\n      this.scanners.set(id, scanner);\n      scanner.start();\n      // Subscription is not required\n      return Promise.resolve();\n    }, async () => {\n      const scanner = this.scanners.get(id);\n      if (scanner != null) {\n        this.scanners.delete(id);\n        await scanner.stop();\n      }\n    }, identity, true);\n  }\n  /**\n   * Returns a stream of old transactions\n   */\n  oldTransactions(address, filter) {\n    const id = (0, utils_1.getUniqueId)();\n    return new StreamImpl((onData, onEnd) => {\n      const scanner = new UnorderedTransactionsScanner(this.provider, {\n        address,\n        onData,\n        onEnd: eof => {\n          this.scanners.delete(id);\n          onEnd(eof);\n        },\n        ...filter\n      });\n      this.scanners.set(id, scanner);\n      scanner.start();\n      // Subscription is not required\n      return Promise.resolve();\n    }, async () => {\n      const scanner = this.scanners.get(id);\n      if (scanner != null) {\n        this.scanners.delete(id);\n        await scanner.stop();\n      }\n    }, identity, true);\n  }\n  states(address) {\n    return this._addSubscription('contractStateChanged', address, false);\n  }\n  async _unsubscribe() {\n    const tasks = [];\n    for (const item of this.subscriptions.values()) {\n      for (const [event, eventData] of Object.entries(item)) {\n        delete item[event];\n        if (eventData != null) {\n          tasks.push(eventData.subscription.then(item => item.unsubscribe()).catch(() => {}));\n        }\n      }\n    }\n    this.subscriptions.clear();\n    for (const scanner of this.scanners.values()) {\n      tasks.push(scanner.stop());\n    }\n    this.scanners.clear();\n    await Promise.all(tasks);\n  }\n  _addSubscription(event, address, isFinite) {\n    const rawAddress = address.toString();\n    const stopProducer = id => {\n      const subscriptions = this.subscriptions.get(rawAddress);\n      if (subscriptions == null) {\n        // No subscriptions for the address\n        return;\n      }\n      const eventData = subscriptions[event];\n      if (eventData != null) {\n        const handler = eventData.handlers.get(id);\n        if (handler != null) {\n          // Remove event handler with the id\n          eventData.handlers.delete(id);\n          const {\n            queue,\n            onEnd,\n            state\n          } = handler;\n          if (!state.finished) {\n            state.finished = true;\n            queue.clear();\n            queue.enqueue(async () => onEnd(state.eof));\n          }\n        }\n        // Remove event data subscription if there are none of them\n        if (eventData.handlers.size === 0) {\n          const subscription = eventData.subscription;\n          delete subscriptions[event];\n          subscription.then(subscription => subscription.unsubscribe()).catch(console.debug);\n        }\n      }\n      // Remove address subscriptions object if it is empty\n      if (subscriptions.contractStateChanged == null && subscriptions.transactionsFound == null) {\n        this.subscriptions.delete(rawAddress);\n      }\n    };\n    const id = (0, utils_1.getUniqueId)();\n    return new StreamImpl((onData, onEnd) => {\n      const subscriptions = this.subscriptions.get(rawAddress);\n      let eventData = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions[event];\n      const state = {\n        eof: false,\n        finished: false\n      };\n      // Create handler object\n      const handler = {\n        onData,\n        onEnd,\n        queue: new PromiseQueue(),\n        state\n      };\n      if (eventData != null) {\n        // Add handler if there is already a handler group\n        eventData.handlers.set(id, handler);\n        return Promise.resolve();\n      }\n      // Create handlers group\n      const handlers = new Map();\n      handlers.set(id, handler);\n      // Create subscription\n      const subscription = this.provider.subscribe(event, {\n        address\n      }).then(subscription => {\n        subscription.on('data', data => {\n          for (const {\n            onData,\n            queue,\n            state\n          } of handlers.values()) {\n            // Skip closed streams\n            if (state.eof || state.finished) {\n              continue;\n            }\n            queue.enqueue(async () => {\n              if (!(await onData(data))) {\n                state.eof = true;\n                stopProducer(id);\n              }\n            });\n          }\n        });\n        subscription.on('unsubscribed', () => {\n          for (const id of handlers.keys()) {\n            stopProducer(id);\n          }\n        });\n        return subscription;\n      }).catch(e => {\n        console.error(e);\n        for (const id of handlers.keys()) {\n          stopProducer(id);\n        }\n        throw e;\n      });\n      // Add event data to subscriptions\n      eventData = {\n        subscription,\n        handlers\n      };\n      if (subscriptions == null) {\n        this.subscriptions.set(rawAddress, {\n          [event]: eventData\n        });\n      } else {\n        subscriptions[event] = eventData;\n      }\n      // Wait until subscribed\n      return subscription.then(() => {});\n    }, () => stopProducer(id), identity, isFinite);\n  }\n}\nexports.Subscriber = Subscriber;\nasync function identity(item, handler) {\n  return handler(item);\n}\nclass StreamImpl {\n  constructor(makeProducer, stopProducer, extractor, isFinite) {\n    this.makeProducer = makeProducer;\n    this.stopProducer = stopProducer;\n    this.extractor = extractor;\n    this.isFinite = isFinite;\n    /**\n     * Folds every element into an accumulator by applying an operation, returning the final result\n     */\n    this.fold = this.onlyFinite((init, f, ctx) => {\n      let state = init;\n      return new Promise((resolve, reject) => {\n        const subscribed = this.makeProducer(\n        // onData\n        data => this.extractor(data, async item => {\n          state = await f(state, item);\n          return true;\n        }),\n        // onEnd\n        eof => {\n          if (eof) {\n            resolve(state);\n          } else {\n            reject(new Error('Subscription closed'));\n          }\n        });\n        if (ctx != null) {\n          ctx.subscribed = subscribed;\n        }\n      });\n    });\n    /**\n     * Waits until the end of the stream\n     */\n    this.finished = this.onlyFinite(ctx => {\n      return new Promise((resolve, reject) => {\n        const subscribed = this.makeProducer(\n        // onData\n        data => this.extractor(data, _item => true),\n        // onEnd\n        eof => {\n          if (eof) {\n            resolve(undefined);\n          } else {\n            reject(new Error('Subscription closed'));\n          }\n        });\n        if (ctx != null) {\n          ctx.subscribed = subscribed;\n        }\n      });\n    });\n  }\n  async delayed(f) {\n    const {\n      subscribed,\n      result\n    } = f({\n      first: () => {\n        const ctx = {};\n        const result = this.first(ctx);\n        return {\n          subscribed: ctx.subscribed,\n          result\n        };\n      },\n      on: handler => {\n        const ctx = {};\n        this.on(handler, ctx);\n        return {\n          subscribed: ctx.subscribed,\n          result: undefined\n        };\n      },\n      fold: this.fold != null ? (init, f) => {\n        const ctx = {};\n        const result = this.fold(init, f, ctx);\n        return {\n          subscribed: ctx.subscribed,\n          result\n        };\n      } : undefined,\n      finished: this.finished != null ? () => {\n        const ctx = {};\n        const result = this.finished(ctx);\n        return {\n          subscribed: ctx.subscribed,\n          result\n        };\n      } : undefined\n    });\n    await subscribed;\n    return () => result;\n  }\n  first(ctx) {\n    const state = {\n      found: false\n    };\n    return new Promise((resolve, reject) => {\n      const subscribed = this.makeProducer(\n      // onData\n      data => this.extractor(data, item => {\n        Object.assign(state, {\n          found: true,\n          result: item\n        });\n        return false;\n      }),\n      // onEnd\n      eof => {\n        if (eof) {\n          if (this.isFinite) {\n            resolve(state.found ? state.result : undefined);\n          } else if (state.found) {\n            resolve(state.result);\n          } else {\n            reject(new Error('Unexpected end of stream'));\n          }\n        } else {\n          reject(new Error('Subscription closed'));\n        }\n      });\n      if (ctx != null) {\n        ctx.subscribed = subscribed;\n      }\n    });\n  }\n  on(handler, ctx) {\n    const subscribed = this.makeProducer(event => this.extractor(event, async item => {\n      await handler(item);\n      return true;\n    }), _eof => {});\n    if (ctx != null) {\n      ctx.subscribed = subscribed;\n    }\n  }\n  merge(other) {\n    return new StreamImpl((onData, onEnd) => {\n      const state = {\n        stopped: false,\n        counter: 0\n      };\n      const checkEnd = eof => {\n        if (state.stopped) {\n          return;\n        }\n        if (++state.counter == 2 || !eof) {\n          state.stopped = true;\n          onEnd(eof);\n        }\n      };\n      return Promise.all([this.makeProducer(onData, checkEnd), other.makeProducer(onData, checkEnd)]).then(() => {});\n    }, () => {\n      this.stopProducer();\n      other.stopProducer();\n    }, this.extractor, this.isFinite && other.isFinite);\n  }\n  enumerate() {\n    const state = {\n      index: 0\n    };\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      return handler({\n        index: state.index++,\n        item\n      });\n    }), this.isFinite);\n  }\n  tap(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      await f(item);\n      return handler(item);\n    }), this.isFinite);\n  }\n  filter(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      if (await f(item)) {\n        return handler(item);\n      } else {\n        return true;\n      }\n    }), this.isFinite);\n  }\n  filterMap(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      const newItem = await f(item);\n      if (newItem !== undefined) {\n        return handler(newItem);\n      } else {\n        return true;\n      }\n    }), this.isFinite);\n  }\n  map(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      const newItem = await f(item);\n      return handler(newItem);\n    }), this.isFinite);\n  }\n  flatMap(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      const items = await f(item);\n      for (const newItem of items) {\n        if (!(await handler(newItem))) {\n          return false;\n        }\n      }\n      return true;\n    }), this.isFinite);\n  }\n  skip(n) {\n    const state = {\n      index: 0\n    };\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, item => {\n      if (state.index >= n) {\n        return handler(item);\n      } else {\n        ++state.index;\n        return true;\n      }\n    }), this.isFinite);\n  }\n  skipWhile(f) {\n    const state = {\n      shouldSkip: true\n    };\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      if (!state.shouldSkip || !(await f(item))) {\n        state.shouldSkip = false;\n        return handler(item);\n      } else {\n        return true;\n      }\n    }), this.isFinite);\n  }\n  take(n) {\n    const state = {\n      index: 0\n    };\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, item => {\n      if (state.index < n) {\n        ++state.index;\n        return handler(item);\n      } else {\n        return false;\n      }\n    }), true);\n  }\n  takeWhile(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      if (await f(item)) {\n        return handler(item);\n      } else {\n        return false;\n      }\n    }), true);\n  }\n  takeWhileMap(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      const newItem = await f(item);\n      if (newItem !== undefined) {\n        return handler(newItem);\n      } else {\n        return false;\n      }\n    }), true);\n  }\n  onlyFinite(f) {\n    if (this.isFinite) {\n      return f;\n    } else {\n      return undefined;\n    }\n  }\n}\nclass UnorderedTransactionsScanner {\n  constructor(provider, params) {\n    this.provider = provider;\n    this.params = params;\n    this.queue = new PromiseQueue();\n    this.isRunning = false;\n  }\n  start() {\n    if (this.isRunning || this.promise != null) {\n      return;\n    }\n    this.isRunning = true;\n    this.promise = (async () => {\n      const params = this.params;\n      const state = {\n        complete: false\n      };\n      while (this.isRunning && !state.complete) {\n        try {\n          const {\n            transactions,\n            continuation\n          } = await this.provider.getTransactions({\n            address: this.params.address,\n            continuation: this.continuation\n          });\n          state.complete = !state.complete && transactions.length == null;\n          if (!this.isRunning || state.complete) {\n            break;\n          }\n          const filteredTransactions = transactions.filter(item => (params.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, params.fromLt) > 0) && (params.fromUtime == null || item.createdAt > params.fromUtime));\n          if (filteredTransactions.length == 0) {\n            state.complete = true;\n            break;\n          }\n          const info = {\n            maxLt: filteredTransactions[0].id.lt,\n            minLt: filteredTransactions[filteredTransactions.length - 1].id.lt,\n            batchType: 'old'\n          };\n          this.queue.enqueue(async () => {\n            const isRunning = await this.params.onData({\n              address: this.params.address,\n              transactions: filteredTransactions,\n              info\n            });\n            if (!isRunning) {\n              state.complete = true;\n              this.isRunning = false;\n            }\n          });\n          if (continuation != null) {\n            this.continuation = continuation;\n          } else {\n            state.complete = true;\n            break;\n          }\n        } catch (e) {\n          console.error(e);\n        }\n      }\n      this.queue.enqueue(async () => this.params.onEnd(state.complete));\n      this.isRunning = false;\n      this.continuation = undefined;\n    })();\n  }\n  async stop() {\n    this.isRunning = false;\n    this.queue.clear();\n    if (this.promise != null) {\n      await this.promise;\n    } else {\n      this.params.onEnd(false);\n    }\n  }\n}\nclass TraceTransactionsScanner {\n  constructor(provider, params) {\n    this.provider = provider;\n    this.params = params;\n    this.queue = new PromiseQueue();\n    this.isRunning = false;\n    this.semaphore = new utils_1.Semaphore(10);\n  }\n  start() {\n    if (this.isRunning || this.promise != null) {\n      return;\n    }\n    const provider = this.provider;\n    this.isRunning = true;\n    this.promise = (async () => {\n      const state = {\n        complete: false\n      };\n      const makePendingTransaction = messageHash => {\n        const state = {\n          stopped: false\n        };\n        const promise = (async () => {\n          let timeout = 500;\n          while (true) {\n            const release = await this.semaphore.acquire();\n            if (state.stopped) {\n              release();\n              return;\n            }\n            const result = await provider.rawApi.findTransaction({\n              inMessageHash: messageHash\n            }).catch(() => ({\n              transaction: undefined\n            })).finally(() => release());\n            if (state.stopped) {\n              return;\n            }\n            if (result.transaction != null) {\n              const transaction = (0, models_1.parseTransaction)(result.transaction);\n              transaction.account = transaction.inMessage.dst;\n              return transaction;\n            }\n            let resolve;\n            const promise = new Promise((resolvePromise, rejectPromise) => {\n              resolve = () => resolvePromise();\n              state.reject = () => rejectPromise();\n            });\n            state.timeout = setTimeout(resolve, timeout);\n            await promise;\n            if (state.stopped) {\n              return;\n            }\n            state.reject = undefined;\n            timeout = Math.min(timeout * 2, 3000);\n          }\n        })();\n        const reject = () => {\n          var _a;\n          state.stopped = true;\n          (_a = state.reject) === null || _a === void 0 ? void 0 : _a.call(state);\n          if (state.timeout != null) {\n            clearTimeout(state.timeout);\n          }\n        };\n        return {\n          promise,\n          reject\n        };\n      };\n      const transactionsQueue = [this.params.origin];\n      try {\n        outer: while (this.isRunning) {\n          const transaction = transactionsQueue.shift();\n          if (transaction == null) {\n            state.complete = true;\n            break;\n          }\n          // Spawn promises\n          const pendingTransactions = transaction.outMessages.filter(message => message.dst != null).map(message => {\n            const messageHash = message.hash;\n            return makePendingTransaction(messageHash);\n          });\n          this.pendingTransactions = pendingTransactions;\n          for (const {\n            promise\n          } of pendingTransactions) {\n            const childTransaction = await promise;\n            if (!this.isRunning || state.complete || childTransaction == null) {\n              break outer;\n            }\n            this.queue.enqueue(async () => {\n              const isRunning = await this.params.onData(childTransaction);\n              if (!isRunning) {\n                state.complete = true;\n                this.isRunning = false;\n                this.rejectPendingTransactions();\n              }\n            });\n            transactionsQueue.push(childTransaction);\n          }\n          this.pendingTransactions = undefined;\n        }\n      } catch (e) {\n        console.error(e);\n        /* do nothing */\n      } finally {\n        this.queue.enqueue(async () => this.params.onEnd(state.complete));\n        this.isRunning = false;\n        this.rejectPendingTransactions();\n      }\n    })();\n  }\n  async stop() {\n    this.isRunning = false;\n    this.queue.clear();\n    this.rejectPendingTransactions();\n    if (this.promise != null) {\n      await this.promise;\n    } else {\n      this.params.onEnd(false);\n    }\n  }\n  rejectPendingTransactions() {\n    if (this.pendingTransactions != null) {\n      for (const pendingTransaction of this.pendingTransactions) {\n        pendingTransaction.reject();\n      }\n      this.pendingTransactions = undefined;\n    }\n    this.semaphore.releaseAll();\n  }\n}\nclass PromiseQueue {\n  constructor() {\n    this.queue = [];\n    this.workingOnPromise = false;\n  }\n  enqueue(promise) {\n    this.queue.push(promise);\n    this._dequeue().catch(() => {});\n  }\n  clear() {\n    this.queue.length = 0;\n  }\n  async _dequeue() {\n    if (this.workingOnPromise) {\n      return;\n    }\n    const item = this.queue.shift();\n    if (!item) {\n      return;\n    }\n    this.workingOnPromise = true;\n    item().then(() => {\n      this.workingOnPromise = false;\n      this._dequeue();\n    }).catch(() => {\n      this.workingOnPromise = false;\n      this._dequeue();\n    });\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Subscriber","utils_1","require","models_1","constructor","provider","subscriptions","Map","scanners","unsubscribe","_unsubscribe","transactions","address","_addSubscription","trace","transaction","id","getUniqueId","StreamImpl","onData","onEnd","scanner","TraceTransactionsScanner","origin","eof","delete","set","start","Promise","resolve","get","stop","identity","oldTransactions","filter","UnorderedTransactionsScanner","states","tasks","item","values","event","eventData","entries","push","subscription","then","catch","clear","all","isFinite","rawAddress","toString","stopProducer","handler","handlers","queue","state","finished","enqueue","size","console","debug","contractStateChanged","transactionsFound","PromiseQueue","subscribe","on","data","keys","e","error","makeProducer","extractor","fold","onlyFinite","init","f","ctx","reject","subscribed","Error","_item","undefined","delayed","result","first","found","assign","_eof","merge","other","stopped","counter","checkEnd","enumerate","index","tap","filterMap","newItem","map","flatMap","items","skip","n","skipWhile","shouldSkip","take","takeWhile","takeWhileMap","params","isRunning","promise","complete","continuation","getTransactions","length","filteredTransactions","fromLt","LT_COLLATOR","compare","lt","fromUtime","createdAt","info","maxLt","minLt","batchType","semaphore","Semaphore","makePendingTransaction","messageHash","timeout","release","acquire","rawApi","findTransaction","inMessageHash","finally","parseTransaction","account","inMessage","dst","resolvePromise","rejectPromise","setTimeout","Math","min","_a","call","clearTimeout","transactionsQueue","outer","shift","pendingTransactions","outMessages","message","hash","childTransaction","rejectPendingTransactions","pendingTransaction","releaseAll","workingOnPromise","_dequeue"],"sources":["/home/king/Desktop/venom-connect-main/examples/react/node_modules/everscale-inpage-provider/dist/stream.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscriber = void 0;\nconst utils_1 = require(\"./utils\");\nconst models_1 = require(\"./models\");\n/**\n * @category Stream\n */\nclass Subscriber {\n    constructor(provider) {\n        this.provider = provider;\n        this.subscriptions = new Map();\n        this.scanners = new Map();\n        this.unsubscribe = async () => this._unsubscribe();\n    }\n    /**\n     * Returns a stream of new transactions\n     */\n    transactions(address) {\n        return this._addSubscription('transactionsFound', address, false);\n    }\n    /**\n     * Returns a finite stream of child transactions\n     * @param transaction - root transaction\n     */\n    trace(transaction) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const scanner = new TraceTransactionsScanner(this.provider, {\n                origin: transaction,\n                onData,\n                onEnd: (eof) => {\n                    this.scanners.delete(id);\n                    onEnd(eof);\n                },\n            });\n            this.scanners.set(id, scanner);\n            scanner.start();\n            // Subscription is not required\n            return Promise.resolve();\n        }, async () => {\n            const scanner = this.scanners.get(id);\n            if (scanner != null) {\n                this.scanners.delete(id);\n                await scanner.stop();\n            }\n        }, identity, true);\n    }\n    /**\n     * Returns a stream of old transactions\n     */\n    oldTransactions(address, filter) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const scanner = new UnorderedTransactionsScanner(this.provider, {\n                address,\n                onData,\n                onEnd: (eof) => {\n                    this.scanners.delete(id);\n                    onEnd(eof);\n                },\n                ...filter,\n            });\n            this.scanners.set(id, scanner);\n            scanner.start();\n            // Subscription is not required\n            return Promise.resolve();\n        }, async () => {\n            const scanner = this.scanners.get(id);\n            if (scanner != null) {\n                this.scanners.delete(id);\n                await scanner.stop();\n            }\n        }, identity, true);\n    }\n    states(address) {\n        return this._addSubscription('contractStateChanged', address, false);\n    }\n    async _unsubscribe() {\n        const tasks = [];\n        for (const item of this.subscriptions.values()) {\n            for (const [event, eventData] of Object.entries(item)) {\n                delete item[event];\n                if (eventData != null) {\n                    tasks.push(eventData.subscription\n                        .then(item => item.unsubscribe())\n                        .catch(() => {\n                    }));\n                }\n            }\n        }\n        this.subscriptions.clear();\n        for (const scanner of this.scanners.values()) {\n            tasks.push(scanner.stop());\n        }\n        this.scanners.clear();\n        await Promise.all(tasks);\n    }\n    _addSubscription(event, address, isFinite) {\n        const rawAddress = address.toString();\n        const stopProducer = (id) => {\n            const subscriptions = this.subscriptions.get(rawAddress);\n            if (subscriptions == null) {\n                // No subscriptions for the address\n                return;\n            }\n            const eventData = subscriptions[event];\n            if (eventData != null) {\n                const handler = eventData.handlers.get(id);\n                if (handler != null) {\n                    // Remove event handler with the id\n                    eventData.handlers.delete(id);\n                    const { queue, onEnd, state } = handler;\n                    if (!state.finished) {\n                        state.finished = true;\n                        queue.clear();\n                        queue.enqueue(async () => onEnd(state.eof));\n                    }\n                }\n                // Remove event data subscription if there are none of them\n                if (eventData.handlers.size === 0) {\n                    const subscription = eventData.subscription;\n                    delete subscriptions[event];\n                    subscription\n                        .then((subscription) => subscription.unsubscribe())\n                        .catch(console.debug);\n                }\n            }\n            // Remove address subscriptions object if it is empty\n            if (subscriptions.contractStateChanged == null && subscriptions.transactionsFound == null) {\n                this.subscriptions.delete(rawAddress);\n            }\n        };\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const subscriptions = this.subscriptions.get(rawAddress);\n            let eventData = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions[event];\n            const state = { eof: false, finished: false };\n            // Create handler object\n            const handler = {\n                onData,\n                onEnd,\n                queue: new PromiseQueue(),\n                state,\n            };\n            if (eventData != null) {\n                // Add handler if there is already a handler group\n                eventData.handlers.set(id, handler);\n                return Promise.resolve();\n            }\n            // Create handlers group\n            const handlers = new Map();\n            handlers.set(id, handler);\n            // Create subscription\n            const subscription = this.provider.subscribe(event, { address })\n                .then((subscription) => {\n                subscription.on('data', (data) => {\n                    for (const { onData, queue, state } of handlers.values()) {\n                        // Skip closed streams\n                        if (state.eof || state.finished) {\n                            continue;\n                        }\n                        queue.enqueue(async () => {\n                            if (!(await onData(data))) {\n                                state.eof = true;\n                                stopProducer(id);\n                            }\n                        });\n                    }\n                });\n                subscription.on('unsubscribed', () => {\n                    for (const id of handlers.keys()) {\n                        stopProducer(id);\n                    }\n                });\n                return subscription;\n            }).catch((e) => {\n                console.error(e);\n                for (const id of handlers.keys()) {\n                    stopProducer(id);\n                }\n                throw e;\n            });\n            // Add event data to subscriptions\n            eventData = { subscription, handlers };\n            if (subscriptions == null) {\n                this.subscriptions.set(rawAddress, { [event]: eventData });\n            }\n            else {\n                subscriptions[event] = eventData;\n            }\n            // Wait until subscribed\n            return subscription.then(() => {\n            });\n        }, () => stopProducer(id), identity, isFinite);\n    }\n}\nexports.Subscriber = Subscriber;\nasync function identity(item, handler) {\n    return handler(item);\n}\nclass StreamImpl {\n    constructor(makeProducer, stopProducer, extractor, isFinite) {\n        this.makeProducer = makeProducer;\n        this.stopProducer = stopProducer;\n        this.extractor = extractor;\n        this.isFinite = isFinite;\n        /**\n         * Folds every element into an accumulator by applying an operation, returning the final result\n         */\n        this.fold = this.onlyFinite((init, f, ctx) => {\n            let state = init;\n            return new Promise((resolve, reject) => {\n                const subscribed = this.makeProducer(\n                // onData\n                (data) => this.extractor(data, async (item) => {\n                    state = await f(state, item);\n                    return true;\n                }), \n                // onEnd\n                (eof) => {\n                    if (eof) {\n                        resolve(state);\n                    }\n                    else {\n                        reject(new Error('Subscription closed'));\n                    }\n                });\n                if (ctx != null) {\n                    ctx.subscribed = subscribed;\n                }\n            });\n        });\n        /**\n         * Waits until the end of the stream\n         */\n        this.finished = this.onlyFinite((ctx) => {\n            return new Promise((resolve, reject) => {\n                const subscribed = this.makeProducer(\n                // onData\n                (data) => this.extractor(data, (_item) => true), \n                // onEnd\n                (eof) => {\n                    if (eof) {\n                        resolve(undefined);\n                    }\n                    else {\n                        reject(new Error('Subscription closed'));\n                    }\n                });\n                if (ctx != null) {\n                    ctx.subscribed = subscribed;\n                }\n            });\n        });\n    }\n    async delayed(f) {\n        const { subscribed, result } = f({\n            first: (() => {\n                const ctx = {};\n                const result = this.first(ctx);\n                return { subscribed: ctx.subscribed, result };\n            }),\n            on: (handler) => {\n                const ctx = {};\n                this.on(handler, ctx);\n                return { subscribed: ctx.subscribed, result: undefined };\n            },\n            fold: this.fold != null ? (init, f) => {\n                const ctx = {};\n                const result = this.fold(init, f, ctx);\n                return { subscribed: ctx.subscribed, result };\n            } : undefined,\n            finished: this.finished != null ? () => {\n                const ctx = {};\n                const result = this.finished(ctx);\n                return { subscribed: ctx.subscribed, result };\n            } : undefined,\n        });\n        await subscribed;\n        return () => result;\n    }\n    first(ctx) {\n        const state = { found: false };\n        return new Promise((resolve, reject) => {\n            const subscribed = this.makeProducer(\n            // onData\n            (data) => this.extractor(data, (item) => {\n                Object.assign(state, { found: true, result: item });\n                return false;\n            }), \n            // onEnd\n            (eof) => {\n                if (eof) {\n                    if (this.isFinite) {\n                        resolve((state.found ? state.result : undefined));\n                    }\n                    else if (state.found) {\n                        resolve(state.result);\n                    }\n                    else {\n                        reject(new Error('Unexpected end of stream'));\n                    }\n                }\n                else {\n                    reject(new Error('Subscription closed'));\n                }\n            });\n            if (ctx != null) {\n                ctx.subscribed = subscribed;\n            }\n        });\n    }\n    on(handler, ctx) {\n        const subscribed = this.makeProducer((event) => this.extractor(event, async (item) => {\n            await handler(item);\n            return true;\n        }), (_eof) => {\n        });\n        if (ctx != null) {\n            ctx.subscribed = subscribed;\n        }\n    }\n    merge(other) {\n        return new StreamImpl((onData, onEnd) => {\n            const state = {\n                stopped: false,\n                counter: 0,\n            };\n            const checkEnd = (eof) => {\n                if (state.stopped) {\n                    return;\n                }\n                if (++state.counter == 2 || !eof) {\n                    state.stopped = true;\n                    onEnd(eof);\n                }\n            };\n            return Promise.all([\n                this.makeProducer(onData, checkEnd),\n                other.makeProducer(onData, checkEnd),\n            ]).then(() => {\n            });\n        }, () => {\n            this.stopProducer();\n            other.stopProducer();\n        }, this.extractor, (this.isFinite && other.isFinite));\n    }\n    enumerate() {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            return handler({\n                index: state.index++,\n                item,\n            });\n        }), this.isFinite);\n    }\n    tap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            await f(item);\n            return handler(item);\n        }), this.isFinite);\n    }\n    filter(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                return handler(item);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    filterMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                return handler(newItem);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    map(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            return handler(newItem);\n        }), this.isFinite);\n    }\n    flatMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const items = await f(item);\n            for (const newItem of items) {\n                if (!(await handler(newItem))) {\n                    return false;\n                }\n            }\n            return true;\n        }), this.isFinite);\n    }\n    skip(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {\n            if (state.index >= n) {\n                return handler(item);\n            }\n            else {\n                ++state.index;\n                return true;\n            }\n        }), this.isFinite);\n    }\n    skipWhile(f) {\n        const state = {\n            shouldSkip: true,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (!state.shouldSkip || !(await f(item))) {\n                state.shouldSkip = false;\n                return handler(item);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    take(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {\n            if (state.index < n) {\n                ++state.index;\n                return handler(item);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    takeWhile(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                return handler(item);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    takeWhileMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                return handler(newItem);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    onlyFinite(f) {\n        if (this.isFinite) {\n            return f;\n        }\n        else {\n            return undefined;\n        }\n    }\n}\nclass UnorderedTransactionsScanner {\n    constructor(provider, params) {\n        this.provider = provider;\n        this.params = params;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n    }\n    start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        this.isRunning = true;\n        this.promise = (async () => {\n            const params = this.params;\n            const state = {\n                complete: false,\n            };\n            while (this.isRunning && !state.complete) {\n                try {\n                    const { transactions, continuation } = await this.provider.getTransactions({\n                        address: this.params.address,\n                        continuation: this.continuation,\n                    });\n                    state.complete = !state.complete && transactions.length == null;\n                    if (!this.isRunning || state.complete) {\n                        break;\n                    }\n                    const filteredTransactions = transactions.filter((item) => ((params.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, params.fromLt) > 0) &&\n                        (params.fromUtime == null || item.createdAt > params.fromUtime)));\n                    if (filteredTransactions.length == 0) {\n                        state.complete = true;\n                        break;\n                    }\n                    const info = {\n                        maxLt: filteredTransactions[0].id.lt,\n                        minLt: filteredTransactions[filteredTransactions.length - 1].id.lt,\n                        batchType: 'old',\n                    };\n                    this.queue.enqueue(async () => {\n                        const isRunning = await this.params.onData({\n                            address: this.params.address,\n                            transactions: filteredTransactions,\n                            info,\n                        });\n                        if (!isRunning) {\n                            state.complete = true;\n                            this.isRunning = false;\n                        }\n                    });\n                    if (continuation != null) {\n                        this.continuation = continuation;\n                    }\n                    else {\n                        state.complete = true;\n                        break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n            this.queue.enqueue(async () => this.params.onEnd(state.complete));\n            this.isRunning = false;\n            this.continuation = undefined;\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.params.onEnd(false);\n        }\n    }\n}\nclass TraceTransactionsScanner {\n    constructor(provider, params) {\n        this.provider = provider;\n        this.params = params;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n        this.semaphore = new utils_1.Semaphore(10);\n    }\n    start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        const provider = this.provider;\n        this.isRunning = true;\n        this.promise = (async () => {\n            const state = {\n                complete: false,\n            };\n            const makePendingTransaction = (messageHash) => {\n                const state = { stopped: false };\n                const promise = (async () => {\n                    let timeout = 500;\n                    while (true) {\n                        const release = await this.semaphore.acquire();\n                        if (state.stopped) {\n                            release();\n                            return;\n                        }\n                        const result = await provider.rawApi.findTransaction({\n                            inMessageHash: messageHash,\n                        }).catch(() => ({ transaction: undefined })).finally(() => release());\n                        if (state.stopped) {\n                            return;\n                        }\n                        if (result.transaction != null) {\n                            const transaction = (0, models_1.parseTransaction)(result.transaction);\n                            transaction.account = transaction.inMessage.dst;\n                            return transaction;\n                        }\n                        let resolve;\n                        const promise = new Promise((resolvePromise, rejectPromise) => {\n                            resolve = () => resolvePromise();\n                            state.reject = () => rejectPromise();\n                        });\n                        state.timeout = setTimeout(resolve, timeout);\n                        await promise;\n                        if (state.stopped) {\n                            return;\n                        }\n                        state.reject = undefined;\n                        timeout = Math.min(timeout * 2, 3000);\n                    }\n                })();\n                const reject = () => {\n                    var _a;\n                    state.stopped = true;\n                    (_a = state.reject) === null || _a === void 0 ? void 0 : _a.call(state);\n                    if (state.timeout != null) {\n                        clearTimeout(state.timeout);\n                    }\n                };\n                return { promise, reject };\n            };\n            const transactionsQueue = [this.params.origin];\n            try {\n                outer: while (this.isRunning) {\n                    const transaction = transactionsQueue.shift();\n                    if (transaction == null) {\n                        state.complete = true;\n                        break;\n                    }\n                    // Spawn promises\n                    const pendingTransactions = transaction\n                        .outMessages\n                        .filter((message) => message.dst != null)\n                        .map((message) => {\n                        const messageHash = message.hash;\n                        return makePendingTransaction(messageHash);\n                    });\n                    this.pendingTransactions = pendingTransactions;\n                    for (const { promise } of pendingTransactions) {\n                        const childTransaction = await promise;\n                        if (!this.isRunning || state.complete || childTransaction == null) {\n                            break outer;\n                        }\n                        this.queue.enqueue(async () => {\n                            const isRunning = await this.params.onData(childTransaction);\n                            if (!isRunning) {\n                                state.complete = true;\n                                this.isRunning = false;\n                                this.rejectPendingTransactions();\n                            }\n                        });\n                        transactionsQueue.push(childTransaction);\n                    }\n                    this.pendingTransactions = undefined;\n                }\n            }\n            catch (e) {\n                console.error(e);\n                /* do nothing */\n            }\n            finally {\n                this.queue.enqueue(async () => this.params.onEnd(state.complete));\n                this.isRunning = false;\n                this.rejectPendingTransactions();\n            }\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        this.rejectPendingTransactions();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.params.onEnd(false);\n        }\n    }\n    rejectPendingTransactions() {\n        if (this.pendingTransactions != null) {\n            for (const pendingTransaction of this.pendingTransactions) {\n                pendingTransaction.reject();\n            }\n            this.pendingTransactions = undefined;\n        }\n        this.semaphore.releaseAll();\n    }\n}\nclass PromiseQueue {\n    constructor() {\n        this.queue = [];\n        this.workingOnPromise = false;\n    }\n    enqueue(promise) {\n        this.queue.push(promise);\n        this._dequeue().catch(() => {\n        });\n    }\n    clear() {\n        this.queue.length = 0;\n    }\n    async _dequeue() {\n        if (this.workingOnPromise) {\n            return;\n        }\n        const item = this.queue.shift();\n        if (!item) {\n            return;\n        }\n        this.workingOnPromise = true;\n        item()\n            .then(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        })\n            .catch(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}